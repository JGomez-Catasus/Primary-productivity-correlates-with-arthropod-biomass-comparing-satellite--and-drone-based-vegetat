---
title: "Sentinel - Índices de Vegetación estimados con Red Edge"
date: "29/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### **OBJETIVO** En este documento evalúa el efecto de los índices de vegetación estimados a partir NIR en Sentinel en: A) la Biomasa de Epígeos; B) la Biomasa de Coleópteros; y C) la Biomasa de Hipógeos

#### **CONCLUSIONES**   

#### 1. Cargamos las librerias necesarias
```{r message= FALSE, warning= FALSE}
library(lattice)
library(ggplot2)
library(plyr)
library(grid)
library(fields)
library(INLA)
library(vegan)
library(readxl)
library(cowplot)
library(Rcmdr)
source("HighstatLibV10.R")
```

#### 2. Cargamos los datos y los preparamos:

Datos:
```{r}
Data <- read_excel("Sentinel_NIR_RE_modfJulia_20201126.xlsx")
```

Quitamos observaciones
```{r}
Data <- subset(Data, Data$Actuation == "Grassland" | Data$Actuation == "Shrub")
```

Las variables relacionadas con la biomasa se van a usar como variables respuesta. Vamos a ver que distribución tienen y si hace falta transformarlas.
```{r}
MyVar <- c("EPIGEOUS_ALL", "COP_ALL", "TIERRA")
Mydotplot(Data[, MyVar])
```     

Transformamos las variables de biomasa usando logaritmo. Las representamos de nuevo y observamos que mejoran sustancialmente. Por lo tanto, trabajaremos con estas variables transformadas.
```{r}
Data$LogEPIGEOUS_ALL <- log10(Data$EPIGEOUS_ALL + 1)
Data$LogCOP_ALL <- log10(Data$COP_ALL + 1)
Data$LogTIERRA <- log10(Data$TIERRA + 1)

MyVar <- c("EPIGEOUS_ALL", "COP_ALL", "TIERRA",
           "LogEPIGEOUS_ALL", "LogCOP_ALL", "LogTIERRA")
Mydotplot(Data[, MyVar])
```      

**Correlacion entre todos los índices de vegetación**

```{r fig.width= 15, fig.height= 10}
MyVar <- c("RE_ndvi", "RE_endvi", "RE_gdvi", "RE_gipvi", "RE_gndvi", "RE_grvi", "RE_gsavi", "RE_bndvi")
Mypairs(Data[,MyVar])
```

Observamos la distribución de los predictores:
```{r}
Mydotplot(Data[,MyVar])
```

Transformadas en logaritmo, no mejoran sustancialmente. Por lo tanto, trabajamos con las variables brutas.
```{r}
Data$RE_NDVILog <- log10(Data$RE_ndvi + 1)
Data$RE_ENDVILog <- log10(Data$RE_endvi + 1)
Data$RE_GDVILog <- log10(Data$RE_gdvi + 1)
Data$RE_GIPVILog <- log10(Data$RE_gipvi + 1)
Data$RE_GNDVILog <- log10(Data$RE_gndvi + 1)
Data$RE_GRVILog <- log10(Data$RE_grvi + 1)
Data$RE_GSAVILog <- log10(Data$RE_gsavi + 1)
Data$RE_BNDVILog <- log10(Data$RE_bndvi + 1)

MyVar <- c("RE_NDVILog", "RE_ENDVILog", "RE_GDVILog", "RE_GIPVILog", "RE_GNDVILog", "RE_GRVILog", "RE_GSAVILog", "RE_BNDVILog")
Mydotplot(Data[,MyVar])
```     

Evaluamos la **colinealidad** entre predictores (year, season y cada índice de vegetación). Valores de GVIF^(1/2Df)>2 indican colinealidad. **No existe colinealidad**

**BNDVI**   
```{r echo= FALSE}
# Creamos la funcion
corvif <- function(dataz) {
  dataz <- as.data.frame(dataz)
  
  #vif part
  form    <- formula(paste("fooy ~ ",paste(strsplit(names(dataz)," "),collapse=" + ")))
  dataz   <- data.frame(fooy=1 + rnorm(nrow(dataz)) ,dataz)
  lm_mod  <- lm(form,dataz)
  
  cat("\n\nVariance inflation factors\n\n")
  print(myvif(lm_mod))
}

# Support function for corvif. Will not be called by the user
myvif <- function(mod) {
  v <- vcov(mod)
  assign <- attributes(model.matrix(mod))$assign
  if (names(coefficients(mod)[1]) == "(Intercept)") {
    v <- v[-1, -1]
    assign <- assign[-1]
  } else warning("No intercept: vifs may not be sensible.")
  terms <- labels(terms(mod))
  n.terms <- length(terms)
  if (n.terms < 2) stop("The model contains fewer than 2 terms")
  if (length(assign) > dim(v)[1] ) {
    diag(tmp_cor)<-0
    if (any(tmp_cor==1.0)){
      return("Sample size is too small, 100% collinearity is present")
    } else {
      return("Sample size is too small")
    }
  }
  R <- cov2cor(v)
  detR <- det(R)
  result <- matrix(0, n.terms, 3)
  rownames(result) <- terms
  colnames(result) <- c("GVIF", "Df", "GVIF^(1/2Df)")
  for (term in 1:n.terms) {
    subs <- which(assign == term)
    result[term, 1] <- det(as.matrix(R[subs, subs])) * det(as.matrix(R[-subs, -subs])) / detR
    result[term, 2] <- length(subs)
  }
  if (all(result[, 2] == 1)) {
    result <- data.frame(GVIF=result[, 1])
  } else {
    result[, 3] <- result[, 1]^(1/(2 * result[, 2]))
  }
  invisible(result)
}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_bndvi")])
```
**ENDVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_endvi")])
```    
**GDVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_gdvi")])
```    

**GIPVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_gipvi")])
```    

**GNDVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_gndvi")])
```     

**GRVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_grvi")])
```    

**GSAVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "Season", "RE_gsavi")])
```   
     
#### A. **Biomasa de Epígeos**

Quitamos los valores sin datos:
```{r}
Data <- Data[-which(is.na(Data$EPIGEOUS_ALL)),]
```

Transformamos en factores las variables categóricas:
```{r}
Data$Year <- as.factor(Data$Year)
Data$Season <- as.factor(Data$Season)
Data$Locality <- as.factor(Data$Locality)
Data$Estacion <- as.factor(Data$Estacion)
Data$Action <- as.factor(Data$Action)
Data$Actuation <- as.factor(Data$Actuation)
str(Data)
```    

#### 3. Empezamos a trabajar con INLA

De cara a incorporar la autocorrelación espacial, se implementan los siguientes 8 pasos:

1. Crear una 'mesh' o malla
2. Definir lo weighting factors $a_ik$ (lo que se denomina la proyector matrix)
3. Definir el SPDE
4. Definir el spatial field
5. Hacer un stack. En este proceso le decimos a INLA en que puntos de la 'mesh' hemos muestreado la variables respuesta y las covariables. Tambien necesitamos informarle a INLA (a traves del Stack) en que puntos tenemos otros terminos (p.ej. otros factores aleatorios no espaciales, si los hubiese)
6. Especificar la formula del modelo en terminos de la variables respuesta, covariables y el termino de autocorrelacion espacial.
7. Correr el modelo en INLA
8. Explorar los resultados
9. Representación conjunta de todos los resultados
10. Validacion del modelo - Spatial confounding


##### **Paso 1**. Crear la mesh o malla

En primer lugar exploramos la distribución de distancias entre los puntos de muestreo: 
```{r}
Loc <- cbind(Data$X/1000, Data$Y/1000)
D <- dist(Loc)

par(mfrow = c(1,2), mar = c(5,5,2,2), cex.lab = 0.75)
hist(D, 
     freq = TRUE,
     main = "", 
     xlab = "Distancia entre estaciones de muestreo (km)",
     ylab = "Frecuencia")
plot (x = sort(D),
      y = (1:length(D))/length(D),
      type = "l",
      xlab = "Distancia entre estaciones de muestreo(km)",
      ylab = "Proporcion Acumulada")
```

Vemos que el 50% de las estaciones estan separadas por menos de 22 km. Esta información es útil a la hora de dar prior distributions y de crear la mesh, ya veremos si es necesario emplearla (en caso de que haya problemas de convergencia de los modelos):
```{r}
sort(D)[which((1:length(D))/length(D) > 0.49999 & (1:length(D))/length(D) < 0.50001)]
```

Creamos una malla. La malla resultante tiene 4695 vertices. Cuanto más vértices más tiempo llevará el ajuste del modelo. Empezamos con una malla muy gruesa, esto se puede refinar en un futuro. De todos modos, los resultados no variarán significativamente:  
```{r}
Bound <- inla.nonconvex.hull(Loc, convex= -0.15)
mesh    <- inla.mesh.2d(boundary= Bound, 
                        max.edge=  c(1,5) # Maxima distancia permitida
)
mesh$n
```
Representamos la malla:
```{r, fig.height= 10, fig.width= 10}
plot(mesh)
points(Loc, col = 1, pch = 16, cex = 1)
```
#####  **Paso 2**. Definir lo weighting factors a_ik (lo que se denomina la proyector matrix)

```{r}
A2 <- inla.spde.make.A(mesh, loc = Loc)
dim(A2)
```

##### **Paso 3**. Definir el SPDE

```{r}
spde <- inla.spde2.matern(mesh, alpha=2)
```

##### **Paso 4**. Definir el spatial field u

```{r}
w.index <- inla.spde.make.index(
  name    = 'w', 
  n.spde  = spde$n.spde)
```

##### **Paso 5**. Hacer un stack 


```{r}
# Polinomios con poly()
Xm <- model.matrix(~ Year + Season + Data$RE_ndvi + poly(Data$RE_ndvi,2) + Data$RE_endvi + poly(Data$RE_endvi,2) + 
                    Data$RE_gdvi + poly(Data$RE_gdvi,2) + Data$RE_gipvi + poly(Data$RE_gipvi,2) + Data$RE_gndvi + poly(Data$RE_gndvi,2) + 
                    Data$RE_grvi + poly(Data$RE_grvi,2) + Data$RE_gsavi + poly(Data$RE_gsavi,2) + Data$RE_bndvi + poly(Data$RE_bndvi,2), data= Data)

X <- data.frame(Intercept= Xm[,1],
                Year2018= Xm[,2],
                Year2019= Xm[,3],
                SeasonSpring= Xm[,4],
                SeasonSummer= Xm[,5],
                SeasonWinter= Xm[,6],
                NDVI= Xm[,7],
                NDVI1= Xm[,8],
                NDVI2 = Xm[,9],
                ENDVI= Xm[,10],
                ENDVI1 = Xm[,11],
                ENDVI2 = Xm[,12],
                GDVI= Xm[,13],
                GDVI1 = Xm[,14],
                GDVI2 = Xm[,15],
                GIPVI = Xm[,16],
                GIPVI1 = Xm[,17],
                GIPVI2 = Xm[,18],
                GNDVI = Xm[,19],
                GNDVI1 = Xm[,20],
                GNDVI2 = Xm[,21],
                GRVI = Xm[,22],
                GRVI1 = Xm[,23],
                GRVI2 = Xm[,24],
                GSAVI = Xm[,25],
                GSAVI1 = Xm[,26],
                GSAVI2 = Xm[,27],
                BNDVI = Xm[,28],
                BNDVI1 = Xm[,29],
                BNDVI2 = Xm[,30])

# Stack para predecir valores y representarlos posteriormente, sin tener en cuenta los factores aleatorios!
# Creamo una base de datos nueva con 2000 valores de los predictores desde el valor minimo al maximo observado
MyData <- data.frame(NDVI= rep(seq(from= range(Data$RE_ndvi)[1],
                                   to= range(Data$RE_ndvi)[2],
                                   length.out= 1000), 9),
                     ENDVI= rep(seq(from= range(Data$RE_endvi)[1],
                                   to= range(Data$RE_endvi)[2],
                                   length.out= 1000), 9),
                     GDVI= rep(seq(from= range(Data$RE_gdvi)[1],
                                   to= range(Data$RE_gdvi)[2],
                                   length.out= 1000), 9),
                     GIPVI= rep(seq(from= range(Data$RE_gipvi)[1],
                                    to= range(Data$RE_gipvi)[2],
                                    length.out= 1000), 9),
                     GNDVI= rep(seq(from= range(Data$RE_gndvi)[1],
                                    to= range(Data$RE_gndvi)[2],
                                    length.out= 1000), 9),
                     GRVI= rep(seq(from= range(Data$RE_grvi)[1],
                                   to= range(Data$RE_grvi)[2],
                                   length.out= 1000), 9),
                     GSAVI= rep(seq(from= range(Data$RE_gsavi)[1],
                                    to= range(Data$RE_gsavi)[2],
                                    length.out= 1000), 9),
                     BNDVI= rep(seq(from= range(Data$RE_bndvi)[1],
                                    to= range(Data$RE_bndvi)[2],
                                    length.out= 1000), 9),
                     Year= c(rep(2017, 1000*2), rep(2018, 1000*3), rep(2019, 1000*4)),
                     Season= c(rep("Summer", 1000), rep("Spring", 1000), 
                              rep("Summer", 1000), rep("Spring", 1000), rep("Autumn", 1000),
                              rep("Winter", 1000), rep("Summer", 1000), rep("Spring", 1000), rep("Autumn", 1000)))

MyData$Season <- as.factor(MyData$Season)
MyData$Year <- as.factor(MyData$Year)


## Polinomios con poly()
Xpred <- model.matrix(~ Year + Season + NDVI + poly(NDVI,2) + ENDVI + poly(ENDVI,2) + GDVI + poly(GDVI,2) + GIPVI + poly(GIPVI,2) +
                      GNDVI + poly(GNDVI,2) + GRVI + poly(GRVI,2) + GSAVI + poly(GSAVI,2) + BNDVI + poly(BNDVI,2),
                      data= MyData)

Xpred <- data.frame(Intercept= Xpred[,1],
                    Year2018= Xpred[,2],
                    Year2019= Xpred[,3],
                    SeasonSpring= Xpred[,4],
                    SeasonSummer= Xpred[,5],
                    SeasonWinter= Xpred[,6],
                    NDVI = Xpred[,7],
                    NDVI1 = Xpred[,8], 
                    NDVI2 = Xpred[,9],
                    ENDVI = Xpred[,10],
                    ENDVI1 = Xpred[,11],
                    ENDVI2 = Xpred[,12],
                    GDVI = Xpred[,13],
                    GDVI1 = Xpred[,14],
                    GDVI2 = Xpred[,15],
                    GIPVI = Xpred[,16],
                    GIPVI1 = Xpred[,17],
                    GIPVI2 = Xpred[,18],
                    GNDVI = Xpred[,19],
                    GNDVI1 = Xpred[,20],
                    GNDVI2 = Xpred[,21],
                    GRVI = Xpred[,22],
                    GRVI1 = Xpred[,23],
                    GRVI2 = Xpred[,24],
                    GSAVI = Xpred[,25],
                    GSAVI1 = Xpred[,26],
                    GSAVI2 = Xpred[,27],
                    BNDVI = Xpred[,28],
                    BNDVI1 = Xpred[,29],
                    BNDVI2 = Xpred[,30])


StackCov <- inla.stack(
  tag = "Covariates",
  data = list(y = NA),  # NA values because we are going to predict these ones!
  A = list(1),                  
  effects = list(Xp = Xpred))

# Stack para la biomasa de epigeos
StackFit_Epigeos <- inla.stack(
  tag  = "Fit",
  data = list(y = Data$LogEPIGEOUS_ALL),  
  A    = list(1,A2),  # Intercept and covariates, spatial field                    
  effects = list(X = X, #Intercept and Covariates
                 w = w.index))          #Spatial field  

All.stacks_Epigeos <- inla.stack(StackFit_Epigeos, StackCov)
```



##### **Paso 6**. Especificar la formula del modelo en terminos de la variables respuesta, covariables y el termino de autocorrelacion espacial

Describimos la ecuación de los modelos. Si el término cuadrático no aparece es porque testamos su efecto y es nulo, por lo tanto, lo quitamos como predictor.

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI Modelo Espacial f(w, model= spde)
f2.BNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(BNDVI) + scale(BNDVI2)  + f(w, model = spde)

# ENDVI Modelo Espacial f(w, model= spde)
f2.ENDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(ENDVI1) + scale(ENDVI2) + f(w, model = spde)

# GDVI Modelo Espacial f(w, model= spde)
f2.GDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GDVI)  + f(w, model = spde)

# GIPVI Modelo Espacial f(w, model= spde)
f2.GIPVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GIPVI1)  + scale(GIPVI2) + f(w, model = spde)

# GNDVI Modelo Espacial f(w, model= spde)
f2.GNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GNDVI1)  + scale(GNDVI2) + f(w, model = spde)

# GRVI Modelo Espacial f(w, model= spde)
f2.GRVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GRVI1)  + scale(GRVI2) + f(w, model = spde)

# GSAVI Modelo Espacial f(w, model= spde)
f2.GSAVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GSAVI1)  + scale(GSAVI2)  + f(w, model = spde)

# NDVI Modelo Espacial f(w, model= spde)
f2.NDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(NDVI) + f(w, model = spde)
```

##### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de epígeos** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI
model.INLA.BNDVI.Epi <- inla(f2.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Epi <- inla(f2.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Epi <- inla(f2.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Epi <- inla(f2.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Epi <- inla(f2.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Epi <- inla(f2.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Epi <- inla(f2.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# NDVI
model.INLA.NDVI.Epi <- inla(f2.NDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término cuadrático (+)

```{r}
model.INLA.BNDVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  

**ENDVI** Término cuadrático (+)

```{r echo= FALSE}
model.INLA.ENDVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  

**GDVI**  Termino cuadratico (-)
```{r echo= FALSE}
model.INLA.GDVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


**GIPVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GIPVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


**GNDVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GNDVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


**GRVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GRVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


**GSAVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GSAVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


**NDVI**  Término lineal (-)
```{r echo= FALSE}
model.INLA.NDVI.Epi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  

Plot:  

```{r}
index.Cov <- inla.stack.index(All.stacks_Epigeos,
                              tag = "Covariates")$data

Predichos <- model.INLA.NDVI.Epi$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$NDVI == unique(MyData$NDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (NDVI= unique(MyData$NDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- exp(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- exp(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- exp(MyData1$Predicted.BCILowlog) -1

p.NDVI <- ggplot(data=MyData1, aes(x=NDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.NDVI <- p.NDVI +  geom_jitter (aes (x=RE_ndvi, y = EPIGEOUS_ALL), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("NDVI") + 
  ylab("Biommass of epigeous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```   


```{r echo= FALSE}
p.NDVI.log <- ggplot(data=MyData1, aes(x=NDVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x=RE_ndvi, y = LogEPIGEOUS_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
 

p.NDVI.log <- p.NDVI.log +   geom_ribbon(data=MyData1, aes(x=NDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("NDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```    


##### **Paso 10**. Validación del modelo ¿Existe spatial confounding?

**A.** Obtenemos los interceptos aleatorios espaciales para cada observacion en cada uno de los modelos

```{r}
w.proj <- inla.mesh.projector(mesh, loc =  Loc)

# u_i para cada modelo
w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Epi$summary.random$w$mean)
w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Epi$summary.random$w$mean)
w.pm_GDVI   <- inla.mesh.project(w.proj, model.INLA.GDVI.Epi$summary.random$w$mean)
w.pm_GIPVI   <- inla.mesh.project(w.proj, model.INLA.GIPVI.Epi$summary.random$w$mean)
w.pm_GNDVI   <- inla.mesh.project(w.proj, model.INLA.GNDVI.Epi$summary.random$w$mean)
w.pm_GRVI   <- inla.mesh.project(w.proj, model.INLA.GRVI.Epi$summary.random$w$mean)
w.pm_GSAVI   <- inla.mesh.project(w.proj, model.INLA.GSAVI.Epi$summary.random$w$mean)
w.pm_NDVI   <- inla.mesh.project(w.proj, model.INLA.NDVI.Epi$summary.random$w$mean)
```

**B.** Ajustamos un modelo enfrentando los valores del intercepto aleatorio espacial frente al factor fijo Type.

En el caso del **BNDVI** observamos que existe 'Spatial Confounding', es decir, el término lineal del 'bndvi' está relacionado con la componente espacial del modelo. Por lo tanto, los resultados presentados mas arriba no son contundentes.

```{r}
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **ENDVI** existe 'Spatial Confounding' con el término lineal
```{r echo= FALSE}
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GDVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgdvi <- inla (w.pm_GDVI ~ scale(GDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgdvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GIPVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgipvi <- inla (w.pm_GIPVI ~ scale(GIPVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgipvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GNDVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgndvi <- inla (w.pm_GNDVI ~ scale(GNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgndvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GRVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgrvi <- inla (w.pm_GRVI ~ scale(GRVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgrvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **NDVI** existe 'Spatial Confounding' con el término cuadrático

```{r echo= FALSE}
SCndvi <- inla (w.pm_NDVI ~ scale(NDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCndvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

Por lo tanto, lo que tenemos que hacer ahora es ajustar de nuevo los modelos estableciendo restricciones en la componente espacial!

### **Paso 6**. Especificar la fórmula del modelo en terminos de la variables respuesta, covariables y el termino de autocorrelación espacial.

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
Xm <- model.matrix(~ Year + Season + 
                     RE_ndvi + poly(RE_ndvi,2) + RE_endvi + poly(RE_endvi,2) + RE_gdvi + 
                     poly(RE_gdvi,2) + RE_gipvi + poly(RE_gipvi,2) + RE_gndvi + 
                     poly(RE_gndvi,2) + RE_grvi + poly(RE_grvi,2) + RE_gsavi + poly(RE_gsavi,2) + 
                     RE_bndvi + poly(RE_bndvi,2), data= Data)

XBndvi <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    BNDVI1 = Xm[,29], BNDVI2 = Xm[,30])
XENDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    ENDVI = Xm[,10])
XENDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    ENDVI1 = Xm[,11], ENDVI2= Xm[,12])
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                     GIPVI = Xm[,16])
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                     GNDVI = Xm[,19])
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                     GRVI = Xm[,22])
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    GSAVI = Xm[,25])

n.covariates.poly= 8 # Intercepto + Year(2) + Month (3) + polinomico de cada indice de vegetacion (2)
n.covariates= 7 # Intercepto + Year(2) + Month (3) + termino lineal de cada indice de vegetacion (1)

Qfact.BNDVI = qr.Q(qr(XBndvi))
Qfact.ENDVI = qr.Q(qr(XENDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))
```

Después describimos las ecuaciones de los modelos. Inicialmente, testamos el efecto del término lineal y el cuadrático. No obstante, si el término cuadrático no tuvo efecto, se quitó de la ecuación.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(BNDVI1) +  scale(BNDVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.ENDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(ENDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.ENDVI)%*%A2), e= rep(0,n.covariates)))
f3.ENDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(ENDVI1) + scale(ENDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.ENDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GIPVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GNDVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GRVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GSAVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates)))
```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de epígeos** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI
model.INLA.BNDVI.Epi_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Epi_SC <- inla(f3.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Epi_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Epi_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Epi_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Epi_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Epigeos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Epigeos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+) y cuadrático (+)

```{r}
model.INLA.BNDVI.Epi_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```     
```{r}
index.Cov <- inla.stack.index(All.stacks_Epigeos,
                              tag = "Covariates")$data

Predichos <- model.INLA.BNDVI.Epi_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$BNDVI == unique(MyData$BNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (BNDVI= unique(MyData$BNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- exp(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- exp(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- exp(MyData1$Predicted.BCILowlog) -1

p.BNDVI <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.BNDVI <- p.BNDVI +  geom_jitter (aes (x=RE_bndvi, y = EPIGEOUS_ALL), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Biommass of epigeous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```   


```{r echo= FALSE}
p.BNDVI.log <- ggplot(data=MyData1, aes(x=BNDVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x=RE_bndvi, y = LogEPIGEOUS_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
  
p.BNDVI.log <- p.BNDVI.log + geom_ribbon(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("BNDVI") + 
  ylab("Log Epigeous Biomass (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```  

**ENDVI** Término lineal (+)

```{r echo= FALSE}
model.INLA.ENDVI.Epi_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  
```{r}
index.Cov <- inla.stack.index(All.stacks_Epigeos,
                              tag = "Covariates")$data

Predichos <- model.INLA.ENDVI.Epi_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$ENDVI == unique(MyData$ENDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (ENDVI= unique(MyData$ENDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- exp(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- exp(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- exp(MyData1$Predicted.BCILowlog) -1

p.ENDVI <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.ENDVI <- p.ENDVI +  geom_jitter (aes (x=RE_endvi, y = EPIGEOUS_ALL), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("Biommass of epigeous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```   


```{r echo= FALSE}
p.ENDVI.log <- ggplot(data=MyData1, aes(x=ENDVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x=RE_endvi, y = LogEPIGEOUS_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE) 
  

p.ENDVI.log <- p.ENDVI.log + geom_ribbon(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.8, 1, 1), "cm"))

```  

**GIPVI** No hay efecto
```{r echo= FALSE}
model.INLA.GIPVI.Epi_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```    


**GNDVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GNDVI.Epi_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   


**GRVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GRVI.Epi_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```    


**GSAVI**  No hay efecto
```{r echo= FALSE}
model.INLA.GSAVI.Epi_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   
   

##### **Paso 9**. Representar los resultados conjuntamente:
```{r, fig.width= 25, fig.height= 8}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.NDVI.log,
          lables= c("A", "B", "C", "D"),
          nrow= 1, ncol= 3)
```
Without GDVI:
```{r, fig.width= 25, fig.height= 8}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.NDVI.log,
          lables= c("A", "B", "C", "D"),
          nrow= 1, ncol= 3)
```


En escala natural:
```{r, fig.width= 10, fig.height= 8, warning= FALSE}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI, p.ENDVI, p.GDVI, p.NDVI,
          lables= c("A", "B", "C", "D"),
          nrow= 2, ncol= 2)
```     



#### B. **Biomasa de Coprófagos**

Quitamos los valores sin datos:
```{r}
Data <- Data[-which(is.na(Data$COP_ALL)),]
```

Transformamos en factores las variables categóricas:
```{r}
Data$Year <- as.factor(Data$Year)
Data$Season <- as.factor(Data$Season)
Data$Locality <- as.factor(Data$Locality)
Data$Estacion <- as.factor(Data$Estacion)
Data$Action <- as.factor(Data$Action)
Data$Actuation <- as.factor(Data$Actuation)
str(Data)
```  

Exploramos la variable respuesta (biomasa de coprófagos en escala natural y logarítmica). Trabajamos con la variable transformada en logaritmo de aquí en adelante. Observamos que existen unos cuantos ceros (10% son ceros)
```{r}
MyVar <- c("COP_ALL", "LogCOP_ALL")
Mydotplot(Data[, MyVar])
```     


#### 3. Empezamos a trabajar con INLA

Del **Paso 1** al **Paso 4** no hace falta repetirlo, ya que es lo mismo que se ha hecho más arriba.

##### **Paso 5**. Hacer un stack 

```{r}
# Stack para la biomasa de coprofagos
StackFit_Coprofagos <- inla.stack(
  tag  = "Fit",
  data = list(y = Data$LogCOP_ALL),  
  A    = list(1,A2),  # Intercept and covariates, spatial field                    
  effects = list(X = X, #Intercept and Covariates
                 w = w.index))          #Spatial field  

All.stacks_Coprofagos <- inla.stack(StackFit_Coprofagos, StackCov)
```


##### **Paso 6**. Especificar la formula del modelo en terminos de la variables respuesta, covariables y el termino de autocorrelacion espacial

Describimos la ecuación de los modelos:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI Modelo Espacial f(w, model= spde)
f2.BNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(BNDVI1) + scale(BNDVI2) + f(w, model = spde)

# ENDVI Modelo Espacial f(w, model= spde)
f2.ENDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(ENDVI1) + scale(ENDVI2) + f(w, model = spde)

# GIPVI Modelo Espacial f(w, model= spde)
f2.GIPVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GIPVI1) +  scale(GIPVI2) + f(w, model = spde)

# GNDVI Modelo Espacial f(w, model= spde)
f2.GNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GNDVI1) + scale(GNDVI2) + f(w, model = spde)

# GRVI Modelo Espacial f(w, model= spde)
f2.GRVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GRVI1) + scale(GRVI2) + f(w, model = spde)

# GSAVI Modelo Espacial f(w, model= spde)
f2.GSAVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GSAVI1) + scale(GSAVI2) + f(w, model = spde)

# NDVI  Modelo Espacial f(w, model= spde)
f2.NDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(NDVI) + f(w, model = spde)

```


##### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de coprófagos** y todos los indices de vegetacion:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de coprofagos
# BNDVI
model.INLA.BNDVI.Cop <- inla(f2.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Cop <- inla(f2.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Cop <- inla(f2.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Cop <- inla(f2.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Cop <- inla(f2.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Cop <- inla(f2.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# NDVI
model.INLA.NDVI.Cop <- inla(f2.NDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```

##### **Paso 8**. Explorar los resultados

**BNDVI** Termino lineal (+)

```{r}
model.INLA.BNDVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  

**ENDVI** Termino lineal (+) y cuadrático (+)

```{r echo= FALSE}
model.INLA.ENDVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  
     
     
**GDVI** No efecto
```{r echo= FALSE}
model.INLA.GDVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
``` 


**GIPVI**  No efecto
```{r echo= FALSE}
model.INLA.GIPVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
``` 

**GNDVI**  No efecto
```{r echo= FALSE}
model.INLA.GNDVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```


**GRVI**  No efecto
```{r echo= FALSE}
model.INLA.GRVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


**GSAVI**  No efecto
```{r echo= FALSE}
model.INLA.GSAVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```    

**NDVI**  No efecto
```{r echo= FALSE}
model.INLA.NDVI.Cop$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  



##### **Paso 10**. Validación del modelo ¿Existe spatial confounding?

**A.** Obtenemos los interceptos aleatorios espaciales para cada observación en cada uno de los modelos

```{r}
w.proj <- inla.mesh.projector(mesh, loc =  Loc)

# u_i para cada modelo
w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Cop$summary.random$w$mean)
w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Cop$summary.random$w$mean)
w.pm_GIPVI   <- inla.mesh.project(w.proj, model.INLA.GIPVI.Cop$summary.random$w$mean)
w.pm_GNDVI   <- inla.mesh.project(w.proj, model.INLA.GNDVI.Cop$summary.random$w$mean)
w.pm_GRVI   <- inla.mesh.project(w.proj, model.INLA.GRVI.Cop$summary.random$w$mean)
w.pm_GSAVI   <- inla.mesh.project(w.proj, model.INLA.GSAVI.Cop$summary.random$w$mean)
w.pm_NDVI   <- inla.mesh.project(w.proj, model.INLA.NDVI.Cop$summary.random$w$mean)
```

**B.** Ajustamos un modelo enfrentando los valores del intercepto aleatorio espacial frente a la covariable con la que sospechamos que puede existir Spatial Confounding (en este caso, los índices de vegetación)

En el caso del **BNDVI** observamos que existe 'Spatial Confounding' con el término lineal

```{r}
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **ENDVI** existe 'Spatial Confounding' con el término lineal y cuadrático
```{r echo= FALSE}
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI1) + scale(ENDVI2),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GIPVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgipvi <- inla (w.pm_GIPVI ~ scale(GIPVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgipvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GNDVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgndvi <- inla (w.pm_GNDVI ~ scale(GNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgndvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```   

En el caso del **GRVI** existe 'Spatial Confounding' con el término lineal

```{r echo= FALSE}
SCgrvi <- inla (w.pm_GRVI ~ scale(GRVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgrvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```    

En el caso del **NDVI** NO existe 'Spatial Confounding'

```{r echo= FALSE}
SCndvi <- inla (w.pm_NDVI ~ scale(NDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCndvi$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
``` 

A continuación, ajustamos de nuevo los modelos estableciendo restricciones en la componente espacial (para que sea ortogonal a las covariables). 

### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:

```{r}
Xm <- model.matrix(~ Year + Season + 
                    RE_ndvi + poly(RE_ndvi,2) + RE_endvi + poly(RE_endvi,2) + RE_gdvi + 
                     poly(RE_gdvi,2) + RE_gipvi + poly(RE_gipvi,2) + RE_gndvi + 
                     poly(RE_gndvi,2) + RE_grvi + poly(RE_grvi,2) + RE_gsavi + poly(RE_gsavi,2) + 
                    RE_bndvi + poly(RE_bndvi,2), data= Data)

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    BNDVI = Xm[,28])
XENDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    ENDVI = Xm[,10])
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                     GIPVI = Xm[,16])
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                     GNDVI = Xm[,19])
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                     GRVI = Xm[,22])
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], Year2019= Xm[,3], SeasonSpring= Xm[,4], SeasonSummer= Xm[,5], SeasonWinter= Xm[,6],
                    GSAVI = Xm[,25])

n.covariates.poly= 8 # Intercepto + Year(2) + Month (3) + polinomico de cada indice de vegetacion (2)
n.covariates= 7 # Intercepto + Year(2) + Month (3) + termino lineal de cada indice de vegetacion (1)

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.ENDVI = qr.Q(qr(XENDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


Despues describimos las ecuaciones de los modelos

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(BNDVI) +  
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates)))

f3.ENDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(ENDVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.ENDVI)%*%A2), e= rep(0,n.covariates)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GIPVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GNDVI) +  +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter + scale(GRVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + Year2019 + SeasonSpring + SeasonSummer + SeasonWinter +  scale(GSAVI) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates)))

# NDVI no existe spatial confounding
```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de coprófagos** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI
model.INLA.BNDVI.Cop_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Cop_SC <- inla(f3.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Cop_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Cop_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Cop_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Cop_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Coprofagos),
                   control.predictor = list(A = inla.stack.A(All.stacks_Coprofagos), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+)

```{r}
model.INLA.BNDVI.Cop_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```      

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Coprofagos,
                              tag = "Covariates")$data

Predichos <- model.INLA.BNDVI.Cop_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$BNDVI == unique(MyData$BNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (BNDVI= unique(MyData$BNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.BNDVI <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.BNDVI <- p.BNDVI +  geom_jitter (aes (x=RE_bndvi, y = 10^(LogCOP_ALL)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Biommass of coprophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```  


```{r echo= FALSE}
p.BNDVI.log <- ggplot(data=MyData1, aes(x=BNDVI,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x=RE_bndvi, y = LogCOP_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
  
p.BNDVI.log <- p.BNDVI.log + geom_ribbon(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("BNDVI") + 
  ylab("Log Coprophagous Biomass (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```     

**ENDVI** Término lineal (+)

```{r echo= FALSE}
model.INLA.ENDVI.Cop_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  
    
```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Coprofagos,
                              tag = "Covariates")$data

Predichos <- model.INLA.ENDVI.Cop_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$ENDVI == unique(MyData$ENDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (ENDVI= unique(MyData$ENDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.ENDVI <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.ENDVI <- p.ENDVI +  geom_jitter (aes (x=RE_endvi, y = 10^(LogCOP_ALL)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("Biommass of coprophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```  


```{r echo= FALSE}
p.ENDVI.log <- ggplot(data=MyData1, aes(x=ENDVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x=RE_endvi, y = LogCOP_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
  

p.ENDVI.log <- p.ENDVI.log + geom_ribbon(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.8, 1, 1), "cm"))

```   


**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Cop_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Coprofagos,
                              tag = "Covariates")$data

Predichos <- model.INLA.GIPVI.Cop_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GIPVI == unique(MyData$GIPVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GIPVI= unique(MyData$GIPVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GIPVI <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GIPVI <- p.GIPVI +  geom_jitter (aes (x= RE_gipvi, y = 10^(LogCOP_ALL)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("Biommass of coprophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```  


```{r echo= FALSE}
p.GIPVI.log <- ggplot(data=MyData1, aes(x=GIPVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x= RE_gipvi, y = LogCOP_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
 

p.GIPVI.log <- p.GIPVI.log +  geom_ribbon(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```     

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Cop_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Coprofagos,
                              tag = "Covariates")$data

Predichos <- model.INLA.GNDVI.Cop_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GNDVI == unique(MyData$GNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GNDVI= unique(MyData$GNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GNDVI <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GNDVI <- p.GNDVI +  geom_jitter (aes (x= RE_gndvi, y = 10^(LogCOP_ALL)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Biommass of coprophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```  


```{r echo= FALSE}
p.GNDVI.log <- ggplot(data=MyData1, aes(x=GNDVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x= RE_gndvi, y = LogCOP_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
  

p.GNDVI.log <- p.GNDVI.log + geom_ribbon(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("GNDVI") + 
  ylab("Log Coprophagous Biomass (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```   

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Cop_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Coprofagos,
                              tag = "Covariates")$data

Predichos <- model.INLA.GRVI.Cop_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GRVI == unique(MyData$GRVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GRVI= unique(MyData$GRVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GRVI <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GRVI <- p.GRVI +  geom_jitter (aes (x= RE_grvi, y = 10^(LogCOP_ALL)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("Biommass of coprophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```  


```{r echo= FALSE}
p.GRVI.log <- ggplot(data=MyData1, aes(x=GRVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
   geom_jitter (aes (x= RE_grvi, y = LogCOP_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE) 
 

p.GRVI.log <- p.GRVI.log +  geom_ribbon(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```  

**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Cop_SC$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
```  


```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Coprofagos,
                              tag = "Covariates")$data

Predichos <- model.INLA.GSAVI.Cop_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GSAVI == unique(MyData$GSAVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GSAVI= unique(MyData$GSAVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GSAVI <- ggplot(data=MyData1, aes(x= GSAVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GSAVI <- p.GSAVI +  geom_jitter (aes (x=RE_gsavi, y = 10^(LogCOP_ALL)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 3, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("Biommass of coprophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), 
                                                axis.title.x = element_text(size = 12, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 12, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 10), plot.margin = margin(0, 0, 0, 0))

```  


```{r echo= FALSE}
p.GSAVI.log <- ggplot(data=MyData1, aes(x=GSAVI, y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_jitter (aes (x=RE_gsavi, y = LogCOP_ALL), data= Data, alpha= 0.4, inherit.aes = FALSE, size= 4, show.legend = FALSE)
  

p.GSAVI.log <- p.GSAVI.log + geom_ribbon(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog), alpha=0.3)  +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 31, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 31, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 27), plot.margin = unit(c(0.5, 0.5, 1, 1), "cm"))

```    

Para el **NDVI** no existía _Spatial Confounding_. El modelo anterior no mostró efecto de este índice de vegetación sobre la biomasa de coprófagos.

##### **Paso 9**. Representar los resultados conjuntamente:     

Los **modelos espaciales con restricciones** ya no predicen valores negativos para la biomasa de coprófagos (como ocurría en los modelos espaciales sin restricciones presentados más arriba). 


Horizontal without GDVI:

```{r, fig.width= 26, fig.height= 15.25}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 2, ncol= 3)
```

En escala natural:
```{r, fig.width= 10, fig.height= 15, warning= FALSE}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI, p.ENDVI, p.GDVI, p.GIPVI,
          p.GNDVI, p.GRVI, p.GSAVI,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 4, ncol= 2)
```



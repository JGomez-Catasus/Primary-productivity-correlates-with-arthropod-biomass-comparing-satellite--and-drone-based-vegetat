---
title: "Drones"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


El **objetivo** de este trabajo es analizar el la relación existente entre la biomasa de artrópodos (epígeos, coprófagos y hipógeos) e índices de vegetación (e.g. BNDVI, NDVI, etc) estimados a partir de imágenes de Sentinel y de drones, con el objeto de evaluar si son una alternativa viable (y menos costosa) a los muestreos pitfall para la cuantificación de la biomasa de artrópodos.

**Análisis estadísticos - Aproximación INLA**: Bajo este enfoque ajustaremos modelos espaciales incorporando un efecto aleatorio espacial (intercepto aleatorio). Para la incorporación del intercepto aleatorio espacial empleamos la aproximación de Laplace (INLA, por sus siglas en inglés) a través de ecuaciones diferenciales estocásticas (SPDE, por sus siglas en inglés). INLA es una aproximación novedosa para realizar inferencia bayesiana, como lo son también los conocidos métodos de Monte Carlo usando cadenas de Markov (MCMC, por sus siglas en inglés). Las ventajas de INLA frente a otros métodos de inferencia bayesiana es que produce resultados más robustos y reduce considerablemente los tiempos de computación en el ajuste de los modelos complejos (p.ej. modelos espaciales). La combinación de INLA con el enfoque SPDE permite el ajuste de modelos espaciales mediante la incorporación de un campo aleatorio de Markov Gaussiano (GRMF, por sus siglas en inglés), para el que la matriz de covarianzas del término residual espacial es aproximada en el marco del SPDE. No obstante, para ello hemos de crear una malla irregular de dos dimensiones que divida el área de estudio en un gran número de triángulos no superpuestos. A este proceso se le denomina triangulación, ampliamente utilizado en métodos de interpolación lineal, y en concreto utilizaremos una generalización de la triangulación de Delaunay, la triangulación de Delaunay restringida. A partir de esta malla irregular y de la aplicación del enfoque SPDE, se estima el intercepto aleatorio espacial y su matriz de covarianzas. A continuación, mediante técnicas de interpolación lineal, se puede obtener el intercepto aleatorio espacial y los valores predichos por el modelo para todo el área de estudio, lo que en nuestro caso representaría la probabilidad de presencia de la alondra ricotí.

#### **OBJETIVO** En este documento evalúa el efecto de los índices de vegetación estimados a partir del Dron en: A) la Biomasa de Epígeos; B) la Biomasa de Coleópteros; y C) la Biomasa de Hipógeos

#### **CONCLUSIONES**    

  a. La **Biomasa de epígeos** se relaciona en positivo con el término lineal de todos los índices de vegetación. Además, se relaciona en negativo con el término cuadrático del ENDVI. El término cuadrático del resto de índices no tiene ningún efecto en la biomasa de epígeos. Existe _Spatial Confounding_, pero la interepretación de los resultados no varía entre los modelos espaciales y los modelos espaciales con restricciones (componente espacial es ortogonal a los predicotres. Únicamente existen diferencias en las estimas de los coeficientes.    
  
  b. En los modelos espaciales ajustados para la **Biomasa de coprófagos** también existe _Spatial Confounding_, y en este caso los resultados cambian sustancialmente. Cuando ajustamos el **modelo espacial sin restricciones** la biomasa de coprófagos se relaciona en positivo con el término lineal de BNDVI y ENDVI, pero no se relaciona con ninguno de los otros índices de vegetación. Sin embargo, cuando ajustamos los **modelos espaciales con restricciones** (componente espacial ortogonal a los predictores), entonces todos los índices de vegetación tienen un efecto positivo sobre la biomasa de coprófagos (únicamente el término lineal). Además, los modelos espacial sin restricciones no son correctos, ya que predicen valores negativos para la biomasa de coprófagos.     
  
  c. La **Biomasa de hipógeos** no se relaciona con ningún índice de vegetación. De cualquier modo, esta variable tiene una alta proporción de ceros (88%), por lo que otros modelos podrían ser más apropiados para analizar esta variable (Zero Inflated models). He mirado por encima y necesitaría más tiempo para aplicarlos en INLA. Si nos compensa, lo hago, pero me llevaría su tiempo. He probado a analizar únicamente presencia/ausencia y hay mucha sobredispersión posiblemente debido al alto número de ceros (199) frente a los 1 (25). Si elimino los ceros y aplico una gaussiana, tampoco hay efecto de los índices de vegetación (N muy pequeña = 25). En cualquier caso, lo resalto porque podría ser una pega de un revisor si es evidente la alta proporción de ceros que tenemos. Por lo tanto, podríamos plantearnos no incorporar esta variable en el artículo.   
  
  

##### 1. Cargamos las librerias necesarias
```{r message= FALSE, warning= FALSE}
library(lattice)
library(ggplot2)
library(plyr)
library(grid)
library(fields)
library(INLA)
library(vegan)
library(readxl)
library(cowplot)
library(Rcmdr)
source("HighstatLibV10.R")
```


#### A. **Biomasa de Epígeos**: Por grupos de consumo

Datos:
```{r}
Data <- read_excel("BBVA_R50_revJulia_20210607.xlsx")
Data <- Data[-which(is.na(Data$Epig_tot)),]

Data$Year<-as.factor(Data$Year)
Data$season<-as.factor(Data$season)
Data$Plot<-as.factor(Data$Plot)
Data$Locality <- as.factor(Data$Locality)
Data$Month <- as.factor(Data$Month)
levels(Data$Locality)
levels(Data$season)
levels(Data$Month)
```  

Exploramos las variables respuesta (escala natural y logarítmica). Trabajamos con la variable transformada en logaritmo de aquí en adelante.
```{r}
Data$LPredators <- log10(Data$Predators + 1)
Data$LDetritiveres <- log10(Data$Detritiveres + 1)
Data$LPhytophagous <- log10(Data$Phytophagous + 1)
Data$LDiverse <- log10(Data$Diverse + 1)

MyVar <- c("LPredators", "Predators", "LDetritiveres", "Detritiveres", "LPhytophagous", "Phytophagous", "LDiverse", "Diverse")
Mydotplot(Data[, MyVar])
```

Exploramos las variables explicativas:
```{r}
MyVar <- c("BNDVI", "ENDVI", "GDVI", "GIPVI", "GNDVI", "GRVI", "GSAVI") # Falta el NDVI en comparacion con Sentinel
Mydotplot(Data[, MyVar])
```


Transformamos las variables explicativas y las exploramos. Más o menos igual.

```{r}
Data$LBNDVI <- log10(Data$BNDVI + 1)
Data$LENDVI <- log10(Data$ENDVI + 1)
Data$LGDVI <- log10(Data$GDVI + 1)
Data$LGIPVI <- log10(Data$GIPVI + 1)
Data$LGNDVI <- log10(Data$GNDVI + 1)
Data$LGRVI <- log10(Data$GRVI + 1)
Data$LGSAVI <- log10(Data$GSAVI + 1)

MyVar <- c("LBNDVI", "LENDVI", "LGDVI", "LGIPVI", "LGNDVI", "LGRVI", "LGSAVI")
Mydotplot(Data[, MyVar])
```

Evaluamos las correlacion entre los indices de vegetacion:    

```{r fig.width= 15, fig.height= 10}
#Make fancy pair plots
Mypairs <- function(Z) {
  MyVarx <- colnames(Z)
  pairs(Z, labels = MyVarx,
        cex.labels =  4,
        lower.panel = function(x, y, digits=2, prefix="", cex.cor = 7) {
          panel.cor(x, y, digits, prefix, cex.cor)}, 
        upper.panel =  function(x, y) points(x, y, 
                                             pch = 16, cex = 0.8, 
                                             col = gray(0.1)))
  #print(P)
}


MyVar <- c("BNDVI", "ENDVI", "GDVI", "GIPVI", "GNDVI", "GRVI", "GSAVI")
MyVar <- c("BNDVI", "ENDVI", "GIPVI", "GNDVI", "GRVI", "GSAVI")
Mypairs(Data[,MyVar])
```
Coeficientes:
```{r}
Coefficients <- c(0.96,0.90,0.91,0.91,0.91,0.91, # BNDVI
                  0.78, 0.78, 0.78, 0.78, 0.78, # ENDVI
                  0.99, 0.99, 0.99, 0.99, # GDVI
                  1, 1, 1, # GIPVI
                  1, 1, # GNDVI
                  1) # GRVI

mean(Coefficients)
sd(Coefficients)
```


Evaluamos la **colinealidad** entre predictores (year, season y cada índice de vegetación). Valores de GVIF^(1/2Df)>2 indican colinealidad. **No existe colinealidad**

**BNDVI**   
```{r echo= FALSE}
# Creamos la funcion
corvif <- function(dataz) {
  dataz <- as.data.frame(dataz)
  
  #vif part
  form    <- formula(paste("fooy ~ ",paste(strsplit(names(dataz)," "),collapse=" + ")))
  dataz   <- data.frame(fooy=1 + rnorm(nrow(dataz)) ,dataz)
  lm_mod  <- lm(form,dataz)
  
  cat("\n\nVariance inflation factors\n\n")
  print(myvif(lm_mod))
}

# Support function for corvif. Will not be called by the user
myvif <- function(mod) {
  v <- vcov(mod)
  assign <- attributes(model.matrix(mod))$assign
  if (names(coefficients(mod)[1]) == "(Intercept)") {
    v <- v[-1, -1]
    assign <- assign[-1]
  } else warning("No intercept: vifs may not be sensible.")
  terms <- labels(terms(mod))
  n.terms <- length(terms)
  if (n.terms < 2) stop("The model contains fewer than 2 terms")
  if (length(assign) > dim(v)[1] ) {
    diag(tmp_cor)<-0
    if (any(tmp_cor==1.0)){
      return("Sample size is too small, 100% collinearity is present")
    } else {
      return("Sample size is too small")
    }
  }
  R <- cov2cor(v)
  detR <- det(R)
  result <- matrix(0, n.terms, 3)
  rownames(result) <- terms
  colnames(result) <- c("GVIF", "Df", "GVIF^(1/2Df)")
  for (term in 1:n.terms) {
    subs <- which(assign == term)
    result[term, 1] <- det(as.matrix(R[subs, subs])) * det(as.matrix(R[-subs, -subs])) / detR
    result[term, 2] <- length(subs)
  }
  if (all(result[, 2] == 1)) {
    result <- data.frame(GVIF=result[, 1])
  } else {
    result[, 3] <- result[, 1]^(1/(2 * result[, 2]))
  }
  invisible(result)
}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "BNDVI")])
```
**ENDVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "ENDVI")])
```    
**GDVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "GDVI")])
```    

**GIPVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "GIPVI")])
```    

**GNDVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "GNDVI")])
```     

**GRVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "GRVI")])
```    

**GSAVI**   
```{r echo= FALSE}
## END VIF FUNCTION
corvif (Data[, c("Year", "season", "GSAVI")])
```   

#### 3. Empezamos a trabajar con INLA

De cara a incorporar la autocorrelacion espacial, se implementan los siguientes 8 pasos:

1. Crear una 'mesh' o malla
2. Definir lo weighting factors $a_ik$ (lo que se denomina la proyector matrix)
3. Definir el SPDE
4. Definir el spatial field
5. Hacer un stack. En este proceso le decimos a INLA en qué puntos de la 'mesh' hemos muestreado la variables respuesta y las covariables. Tambien necesitamos informarle a INLA (a traves del Stack) en que puntos tenemos otros términos (p.ej. otros factores aleatorios no espaciales, si los hubiese)
6. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.
7. Correr el modelo en INLA
8. Explorar los resultados
9. Representación conjunta de todos los resultados
10. Validación del modelo - Spatial confounding


##### **Paso 1**. Crear la mesh o malla

En primer lugar exploramos la distribucion de distancias entre los puntos de muestreo: 
```{r}
Loc <- cbind(Data$X/1000, Data$Y/1000)
D <- dist(Loc)

par(mfrow = c(1,2), mar = c(5,5,2,2), cex.lab = 0.75)
hist(D, 
     freq = TRUE,
     main = "", 
     xlab = "Distancia entre estaciones de muestreo (km)",
     ylab = "Frecuencia")
plot (x = sort(D),
      y = (1:length(D))/length(D),
      type = "l",
      xlab = "Distancia entre estaciones de muestreo(km)",
      ylab = "Proporcion Acumulada")
```

Vemos que el 50% de las estaciones estan separadas por menos de 11 km. Esta información es útil a la hora de dar prior distributions y de crear la mesh, ya veremos si es necesario emplearla (en caso de que haya problemas de convergencia de los modelos):
```{r}
sort(D)[which((1:length(D))/length(D) > 0.49 & (1:length(D))/length(D) < 0.50001)]
```

Creamos una malla. La malla resultante tiene 1695 vertices. Cuanto más vértices más tiempo llevará el ajuste del modelo. Esto se puede refinar en un futuro. De todos modos, los resultados no variarán significativamente:  
```{r}
Bound <- inla.nonconvex.hull(Loc, convex= -0.15)
mesh    <- inla.mesh.2d(boundary= Bound, 
                        max.edge=  c(1,5) # Maxima distancia permitida
)
mesh$n
```

Representamos la malla:
```{r, fig.height= 10, fig.width= 10}
plot(mesh)
points(Loc, col = 1, pch = 16, cex = 1)
```
#####  **Paso 2**. Definir lo weighting factors a_ik (lo que se denomina la proyector matrix)

```{r}
A2 <- inla.spde.make.A(mesh, loc = Loc)
dim(A2)
```

##### **Paso 3**. Definir el SPDE

```{r}
spde <- inla.spde2.matern(mesh, alpha=2)
```

##### **Paso 4**. Definir el spatial field u

```{r}
w.index <- inla.spde.make.index(
  name    = 'w', 
  n.spde  = spde$n.spde)
```

##### **Paso 5**. Hacer un stack 

Recomiendan utilizar la funcion poly() para añadir las relaciones cuadráticas, porque produce polinomios ortogonales y evita colinearidad entre predictores: https://stats.stackexchange.com/questions/421988/why-prefer-poly-to-i-are-they-different   

Lo compruebo y efectivamente, cuando empleo I() existe colinealidad entre predictores (valores altos >50 del GVIF). Sin embargo, esta desaparece empleando poly().

```{r}
Xm <- model.matrix(~ Year + season + ENDVI + poly(Data$ENDVI,2) + GDVI + poly(Data$GDVI,2) + GIPVI + poly(Data$GIPVI,2) +
                     GNDVI + poly(Data$GNDVI,2) + GRVI + poly(Data$GRVI,2) + GSAVI + poly(Data$GSAVI,2) + BNDVI + poly(Data$BNDVI,2), data= Data)

X <- data.frame(Intercept= Xm[,1],
                Year2018= Xm[,2],
                seasonspring= Xm[,3],
                seasonsummer= Xm[,4],
                ENDVI= Xm[,5],
                ENDVI1 = Xm[,6],
                ENDVI2 = Xm[,7],
                GDVI = Xm[,8],
                GDVI1 = Xm[,9],
                GDVI2 = Xm[,10],
                GIPVI = Xm[,11],
                GIPVI1 = Xm[,12],
                GIPVI2 = Xm[,13],
                GNDVI = Xm[,14],
                GNDVI1 = Xm[,15],
                GNDVI2 = Xm[,16],
                GRVI = Xm[,17],
                GRVI1 = Xm[,18],
                GRVI2 = Xm[,19],
                GSAVI = Xm[,20],
                GSAVI1 = Xm[,21],
                GSAVI2 = Xm[,22],
                BNDVI = Xm[,23],
                BNDVI1 = Xm[,24],
                BNDVI2 = Xm[,25])

# Stack para predecir valores y representarlos posteriormente, sin tener en cuenta los factores aleatorios!
# Creamo una base de datos nueva con 2000 valores de los predictores desde el valor minimo al maximo observado
MyData <- data.frame(ENDVI= rep(seq(from= range(Data$ENDVI)[1],
                                   to= range(Data$ENDVI)[2],
                                   length.out= 1000), 5),
                     ENDVI1= rep(poly(seq(from= range(Data$ENDVI)[1],
                                   to= range(Data$ENDVI)[2],
                                   length.out= 1000),2)[,1], 5),
                     ENDVI2= rep(poly(seq(from= range(Data$ENDVI)[1],
                                   to= range(Data$ENDVI)[2],
                                   length.out= 1000),2)[,2], 5),
                     GDVI= rep(seq(from= range(Data$GDVI)[1],
                                   to= range(Data$GDVI)[2],
                                   length.out= 1000), 5),
                     GDVI1= rep(poly(seq(from= range(Data$GDVI)[1],
                                   to= range(Data$GDVI)[2],
                                   length.out= 1000), 2)[,1], 5),
                     GDVI2= rep(poly(seq(from= range(Data$GDVI)[1],
                                   to= range(Data$GDVI)[2],
                                   length.out= 1000), 2)[,2], 5),
                     GIPVI= rep(seq(from= range(Data$GIPVI)[1],
                                    to= range(Data$GIPVI)[2],
                                    length.out= 1000), 5),
                     GIPVI1= rep(poly(seq(from= range(Data$GIPVI)[1],
                                    to= range(Data$GIPVI)[2],
                                    length.out= 1000), 2)[,1], 5),
                     GIPVI2= rep(poly(seq(from= range(Data$GIPVI)[1],
                                    to= range(Data$GIPVI)[2],
                                    length.out= 1000), 2)[,2], 5),
                     GNDVI= rep(seq(from= range(Data$GNDVI)[1],
                                    to= range(Data$GNDVI)[2],
                                    length.out= 1000), 5),
                     GNDVI1= rep(poly(seq(from= range(Data$GNDVI)[1],
                                    to= range(Data$GNDVI)[2],
                                    length.out= 1000),2)[,1], 5),
                     GNDVI2= rep(poly(seq(from= range(Data$GNDVI)[1],
                                    to= range(Data$GNDVI)[2],
                                    length.out= 1000),2)[,2], 5),
                     GRVI= rep(seq(from= range(Data$GRVI)[1],
                                   to= range(Data$GRVI)[2],
                                   length.out= 1000), 5),
                     GRVI1= rep(poly(seq(from= range(Data$GRVI)[1],
                                   to= range(Data$GRVI)[2],
                                   length.out= 1000),2)[,1], 5),
                     GRVI2= rep(poly(seq(from= range(Data$GRVI)[1],
                                   to= range(Data$GRVI)[2],
                                   length.out= 1000),2)[,2], 5),
                     GSAVI= rep(seq(from= range(Data$GSAVI)[1],
                                    to= range(Data$GSAVI)[2],
                                    length.out= 1000), 5),
                     GSAVI1= rep(poly(seq(from= range(Data$GSAVI)[1],
                                    to= range(Data$GSAVI)[2],
                                    length.out= 1000),2)[,1], 5),
                     GSAVI2= rep(poly(seq(from= range(Data$GSAVI)[1],
                                    to= range(Data$GSAVI)[2],
                                    length.out= 1000),2)[,2], 5),
                     BNDVI= rep(seq(from= range(Data$BNDVI)[1],
                                    to= range(Data$BNDVI)[2],
                                    length.out= 1000), 5),
                     BNDVI1= rep(poly(seq(from= range(Data$BNDVI)[1],
                                    to= range(Data$BNDVI)[2],
                                    length.out= 1000),2)[,1], 5),
                     BNDVI2= rep(poly(seq(from= range(Data$BNDVI)[1],
                                    to= range(Data$BNDVI)[2],
                                    length.out= 1000),2)[,2], 5),
                     Year= c(rep(2017, 1000*2), rep(2018, 1000*3)),
                     season= c(rep("spring", 1000), rep("summer", 1000), 
                              rep("spring", 1000), rep("summer", 1000), rep("autumn", 1000)))

MyData$Year <- as.factor(MyData$Year)
MyData$season <- as.factor(MyData$season)


Xpred <- model.matrix(~ Year + season + ENDVI + ENDVI1 + ENDVI2 + GDVI + GDVI1 + GDVI2 + GIPVI + GIPVI1 + GIPVI2 + GNDVI + GNDVI1 + GNDVI2 + 
                        GRVI + GRVI1 + GRVI2 + GSAVI + GSAVI1 + GSAVI2 + BNDVI + BNDVI1 + BNDVI2,
                      data= MyData)

Xpred <- data.frame(Intercept= Xpred[,1],
                Year2018= Xpred[,2],
                seasonspring= Xpred[,3],
                seasonsummer= Xpred[,4],
                ENDVI= Xpred[,5],
                ENDVI1 = Xpred[,6],
                ENDVI2 = Xpred[,7],
                GDVI = Xpred[,8],
                GDVI1 = Xpred[,9],
                GDVI2 = Xpred[,10],
                GIPVI = Xpred[,11],
                GIPVI1 = Xpred[,12],
                GIPVI2 = Xpred[,13],
                GNDVI = Xpred[,14],
                GNDVI1 = Xpred[,15],
                GNDVI2 = Xpred[,16],
                GRVI = Xpred[,17],
                GRVI1 = Xpred[,18],
                GRVI2 = Xpred[,19],
                GSAVI = Xpred[,20],
                GSAVI1 = Xpred[,21],
                GSAVI2 = Xpred[,22],
                BNDVI = Xpred[,23],
                BNDVI1 = Xpred[,24],
                BNDVI2 = Xpred[,25])

StackCov <- inla.stack(
  tag = "Covariates",
  data = list(y = NA),  # NA values because we are going to predict these ones!
  A = list(1),                  
  effects = list(Xp = Xpred))

# Stack para la biomasa de predators
StackFit_Predators <- inla.stack(
  tag  = "Fit",
  data = list(y = Data$LPredators),  
  A    = list(1,A2),  # Intercept and covariates, spatial field                    
  effects = list(X = X, #Intercept and Covariates
                 w = w.index))          #Spatial field  

# Stack para la biomasa de detritiveres
StackFit_Detritiveres <- inla.stack(
  tag  = "Fit",
  data = list(y = Data$LDetritiveres),  
  A    = list(1,A2),  # Intercept and covariates, spatial field                    
  effects = list(X = X, #Intercept and Covariates
                 w = w.index))          #Spatial field 

# Stack para la biomasa de phytophagous
StackFit_Phytophagous <- inla.stack(
  tag  = "Fit",
  data = list(y = Data$LPhytophagous),  
  A    = list(1,A2),  # Intercept and covariates, spatial field                    
  effects = list(X = X, #Intercept and Covariates
                 w = w.index))          #Spatial field

# Stack para la biomasa de Diverse
StackFit_Diverse <- inla.stack(
  tag  = "Fit",
  data = list(y = Data$LDiverse),  
  A    = list(1,A2),  # Intercept and covariates, spatial field                    
  effects = list(X = X, #Intercept and Covariates
                 w = w.index))          #Spatial field

All.stacks_Predators <- inla.stack(StackFit_Predators, StackCov)
All.stacks_Detritiveres <- inla.stack(StackFit_Detritiveres, StackCov)
All.stacks_Phytophagous <- inla.stack(StackFit_Phytophagous, StackCov)
All.stacks_Diverse<- inla.stack(StackFit_Diverse, StackCov)
```


##### **Paso 6**. Especificar la formula del modelo en terminos de la variables respuesta, covariables y el termino de autocorrelacion espacial

Describimos la ecuación de los modelos. Si no incorporamos el término cuadrático es porque ya se ha comprobado que no tiene efecto.

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
f2.null <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + f(w, model = spde)

# BNDVI Modelo Espacial f(w, model= spde)
f2.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI1) + scale(BNDVI2) + f(w, model = spde)

# ENDVI Modelo Espacial f(w, model= spde)
f2.ENDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(ENDVI1) + scale(ENDVI2) + f(w, model = spde)

# GDVI Modelo Espacial f(w, model= spde)
f2.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI1) + scale(GDVI2) + f(w, model = spde)

# GIPVI Modelo Espacial f(w, model= spde)
f2.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI1) + scale(GIPVI2) + f(w, model = spde)

# GNDVI Modelo Espacial f(w, model= spde)
f2.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI1) + scale(GNDVI2) + f(w, model = spde)

# GRVI Modelo Espacial f(w, model= spde)
f2.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI1) +  scale(GRVI2) +  f(w, model = spde)

# GSAVI Modelo Espacial f(w, model= spde)
f2.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI1) + scale(GSAVI2) + f(w, model = spde)

```


##### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de predators** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
Null.INLA.Predat <- inla(f2.null,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# BNDVI
model.INLA.BNDVI.Predat <- inla(f2.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Predat <- inla(f2.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Predat <- inla(f2.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Predat <- inla(f2.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Predat <- inla(f2.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Predat <- inla(f2.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Predat <- inla(f2.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```    


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+)

```{r}
model.INLA.BNDVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**ENDVI** Término lineal (+) y Término cuadrático (-)

```{r}
model.INLA.ENDVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GDVI** Término lineal (+)

```{r}
model.INLA.GDVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GIPVI** Término lineal (+)

```{r}
model.INLA.GIPVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GNDVI** Término lineal (+)

```{r}
model.INLA.GNDVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GRVI** Término lineal (+)

```{r}
model.INLA.GRVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GSAVI** Término lineal (+)

```{r}
model.INLA.GSAVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
``` 

 
##### **Paso 10**. Validacion del modelo ¿Existe spatial confounding?

**A.** Obtenemos los interceptos aleatorios espaciales para cada observación en cada uno de los modelos

```{r}
w.proj <- inla.mesh.projector(mesh, loc =  Loc)

# u_i para cada modelo
w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Predat$summary.random$w$mean)
w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Predat$summary.random$w$mean)
w.pm_GDVI   <- inla.mesh.project(w.proj, model.INLA.GDVI.Predat$summary.random$w$mean)
w.pm_GIPVI   <- inla.mesh.project(w.proj, model.INLA.GIPVI.Predat$summary.random$w$mean)
w.pm_GNDVI   <- inla.mesh.project(w.proj, model.INLA.GNDVI.Predat$summary.random$w$mean)
w.pm_GRVI   <- inla.mesh.project(w.proj, model.INLA.GRVI.Predat$summary.random$w$mean)
w.pm_GSAVI   <- inla.mesh.project(w.proj, model.INLA.GSAVI.Predat$summary.random$w$mean)
```

**B.** Ajustamos un modelo enfrentando los valores del intercepto aleatorio espacial frente a la covariable con la que sospechamos que puede existir Spatial Confounding (en este caso, los índices de vegetación)

En el caso del **BNDVI** observamos que NO existe 'Spatial Confounding', es decir, el término lineal del 'bndvi' NO está relacionado con la componente espacial del modelo. Por lo tanto, los resultados presentados mas arriba son contundentes.

```{r}
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

Ajustamos de nuevo el modelo sin el termino cuadratico porque no era significativo. Y comprobamos que si que hay spatial confounding:
```{r}
# BNDVI Modelo Espacial f(w, model= spde)
f2.BNDVIb <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI1) + f(w, model = spde)
# BNDVI
model.INLA.BNDVI.Predat <- inla(f2.BNDVIb,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
model.INLA.BNDVI.Predat$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]

w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Predat$summary.random$w$mean)
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

En el caso del **ENDVI** NO existe 'Spatial Confounding', ni en el término lineal ni en el término cuadrático
```{r echo= FALSE}
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI) + scale(ENDVI2),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```        

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.ENDVI.Predat$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$ENDVI == unique(MyData$ENDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (ENDVI= unique(MyData$ENDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.ENDVI <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.ENDVI <- p.ENDVI +  geom_jitter (aes (x=ENDVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.ENDVI.log <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.ENDVI.log <- p.ENDVI.log +  geom_jitter (aes (x=ENDVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```     

En el caso del **GDVI** existe 'Spatial Confounding', tanto en el término lineal como en el término cuadrático. Por lo tanto, los resultados expuestos anteriormente no son contundentes.

```{r echo= FALSE}
SCgdvi <- inla (w.pm_GDVI ~ scale(GDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgdvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GIPVI** existe 'Spatial Confounding' en el término lineal

```{r echo= FALSE}
SCgipvi <- inla (w.pm_GIPVI ~ scale(GIPVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgipvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GNDVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgndvi <- inla (w.pm_GNDVI ~ scale(GNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GRVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgrvi <- inla (w.pm_GRVI ~ scale(GRVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgrvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GSAVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgsavi <- inla (w.pm_GSAVI ~ scale(GSAVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgsavi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

A continuación, ajustamos de nuevo los modelos estableciendo restricciones en la componente espacial (para que sea ortogonal a las covariables).     

##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], BNDVI1 = scale(Xm[,24]), BNDVI2 = scale(Xm[,25]))
XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI1 = scale(Xm[,9]), GDVI2 = scale(Xm[,10]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI1 = scale(Xm[,12]), GIPVI1 = scale(Xm[,13]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI1 = scale(Xm[,15]), GNDVI2 = scale(Xm[,16]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI1 = scale(Xm[,18]), GRVI2 = scale(Xm[,19]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI1 = scale(Xm[,21]), GSAVI2 = scale(Xm[,22]))

n.covariates.poly= 6 # Intercept (1) + Year (1) + Season (2) + polinomio del indice de vegetacion (2)
n.covariates= 5 # Intercept (1) + Year (1) + Season (2) +termino lineal del indice de vegetacion (1) --> No intorudcimos el termino cuadratico porque no fue significativo

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI1) + scale(BNDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI1) + scale(GDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI1) + scale(GIPVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI1) + scale(GNDVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI1) + scale(GRVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI1) + scale(GSAVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates.poly)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de predatory arthropods** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de predatory arthropods
# BNDVI
model.INLA.BNDVI.Predat_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Predat_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Predat_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Predat_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Predat_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Predat_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+)

```{r}
model.INLA.BNDVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     



**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      


**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

  

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    


**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], BNDVI = scale(Xm[,23]))
XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI = scale(Xm[,8]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI = scale(Xm[,11]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI = scale(Xm[,14]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI = scale(Xm[,17]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI = scale(Xm[,20]))

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de epígeos** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI
model.INLA.BNDVI.Predat_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Predat_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Predat_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Predat_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Predat_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Predat_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Predators),
                   control.predictor = list(A = inla.stack.A(All.stacks_Predators), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+)

```{r}
model.INLA.BNDVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.BNDVI.Predat_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$BNDVI == unique(MyData$BNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (BNDVI= unique(MyData$BNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.BNDVI <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.BNDVI <- p.BNDVI +  geom_jitter (aes (x= BNDVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Predatory arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.BNDVI.log <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.BNDVI.log <- p.BNDVI.log +  geom_jitter (aes (x= BNDVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Log predatory arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.GDVI.Predat_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GDVI == unique(MyData$GDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GDVI= unique(MyData$GDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GDVI <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GDVI <- p.GDVI +  geom_jitter (aes (x=GDVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GDVI.log <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GDVI.log <- p.GDVI.log +  geom_jitter (aes (x=GDVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```

**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.GIPVI.Predat_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GIPVI == unique(MyData$GIPVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GIPVI= unique(MyData$GIPVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GIPVI <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GIPVI <- p.GIPVI +  geom_jitter (aes (x=GIPVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GIPVI.log <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GIPVI.log <- p.GIPVI.log +  geom_jitter (aes (x=GIPVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```     

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.GNDVI.Predat_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GNDVI == unique(MyData$GNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GNDVI= unique(MyData$GNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GNDVI <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GNDVI <- p.GNDVI +  geom_jitter (aes (x=GNDVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Predatory arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GNDVI.log <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GNDVI.log <- p.GNDVI.log +  geom_jitter (aes (x=GNDVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Log predatory arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```   

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.GRVI.Predat_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GRVI == unique(MyData$GRVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GRVI= unique(MyData$GRVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GRVI <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GRVI <- p.GRVI +  geom_jitter (aes (x=GRVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GRVI.log <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GRVI.log <- p.GRVI.log +  geom_jitter (aes (x=GRVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  

**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Predat_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Predators,
                              tag = "Covariates")$data

Predichos <- model.INLA.GSAVI.Predat_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GSAVI == unique(MyData$GSAVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GSAVI= unique(MyData$GSAVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GSAVI <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GSAVI <- p.GSAVI +  geom_jitter (aes (x=GSAVI, y = 10^(LPredators)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GSAVI.log <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GSAVI.log <- p.GSAVI.log +  geom_jitter (aes (x=GSAVI, y = LPredators), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


##### **Paso 9**. Representar los resultados conjuntamente:

En los nuevos gráficos el 95% Bayesian Confidence Interval se hace más estrecho:    

```{r, fig.width= 15, fig.height= 24}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 4, ncol= 2)
```
 
 Horizontal:

```{r, fig.width= 25, fig.height= 13}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 2, ncol= 3)
```

En escala natural (quito GDVI, valores raros):
```{r, fig.width= 25, fig.height= 13, warning= FALSE}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI, p.ENDVI,p.GIPVI,
          p.GNDVI, p.GRVI, p.GSAVI,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 2, ncol= 3)
```



#### B. **Biomasa de Detritiveres arthropods**

##### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de detritiveres** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
Null.INLA.Detri <- inla(f2.null,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# BNDVI
model.INLA.BNDVI.Detri <- inla(f2.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Detri <- inla(f2.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Detri <- inla(f2.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Detri <- inla(f2.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Detri <- inla(f2.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Detri <- inla(f2.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Detri <- inla(f2.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```    


##### **Paso 8**. Explorar los resultados

**BNDVI**

```{r}
model.INLA.BNDVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**ENDVI**

```{r}
model.INLA.ENDVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GDVI**

```{r}
model.INLA.GDVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GIPVI**

```{r}
model.INLA.GIPVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GNDVI**

```{r}
model.INLA.GNDVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GRVI**

```{r}
model.INLA.GRVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GSAVI**

```{r}
model.INLA.GSAVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
``` 

 
##### **Paso 10**. Validacion del modelo ¿Existe spatial confounding?

**A.** Obtenemos los interceptos aleatorios espaciales para cada observación en cada uno de los modelos

```{r}
w.proj <- inla.mesh.projector(mesh, loc =  Loc)

# u_i para cada modelo
w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Detri$summary.random$w$mean)
w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Detri$summary.random$w$mean)
w.pm_GDVI   <- inla.mesh.project(w.proj, model.INLA.GDVI.Detri$summary.random$w$mean)
w.pm_GIPVI   <- inla.mesh.project(w.proj, model.INLA.GIPVI.Detri$summary.random$w$mean)
w.pm_GNDVI   <- inla.mesh.project(w.proj, model.INLA.GNDVI.Detri$summary.random$w$mean)
w.pm_GRVI   <- inla.mesh.project(w.proj, model.INLA.GRVI.Detri$summary.random$w$mean)
w.pm_GSAVI   <- inla.mesh.project(w.proj, model.INLA.GSAVI.Detri$summary.random$w$mean)
```

**B.** Ajustamos un modelo enfrentando los valores del intercepto aleatorio espacial frente a la covariable con la que sospechamos que puede existir Spatial Confounding (en este caso, los índices de vegetación)

En el caso del **BNDVI** observamos que existe 'Spatial Confounding', es decir, el término lineal del 'bndvi' está relacionado con la componente espacial del modelo. Por lo tanto, los resultados presentados mas arriba NO son contundentes.

```{r}
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   


En el caso del **ENDVI** NO existe 'Spatial Confounding', ni en el término lineal ni en el término cuadrático
```{r echo= FALSE}
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI) + scale(ENDVI2),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```        

Ajustamos de nuevo el modelo sin el termino cuadratico porque no era significativo. Y comprobamos que si que hay spatial confounding:
```{r}
# BNDVI Modelo Espacial f(w, model= spde)
f2.ENDVIb <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(ENDVI1) + f(w, model = spde)

# BNDVI
model.INLA.ENDVI.Detri <- inla(f2.ENDVIb,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
model.INLA.ENDVI.Detri$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]

w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Detri$summary.random$w$mean)
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

En el caso del **GDVI** existe 'Spatial Confounding', tanto en el término lineal como en el término cuadrático. Por lo tanto, los resultados expuestos anteriormente no son contundentes.

```{r echo= FALSE}
SCgdvi <- inla (w.pm_GDVI ~ scale(GDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgdvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GIPVI** existe 'Spatial Confounding' en el término lineal

```{r echo= FALSE}
SCgipvi <- inla (w.pm_GIPVI ~ scale(GIPVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgipvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GNDVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgndvi <- inla (w.pm_GNDVI ~ scale(GNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GRVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgrvi <- inla (w.pm_GRVI ~ scale(GRVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgrvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GSAVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgsavi <- inla (w.pm_GSAVI ~ scale(GSAVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgsavi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

A continuación, ajustamos de nuevo los modelos estableciendo restricciones en la componente espacial (para que sea ortogonal a las covariables).     

##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], BNDVI1 = scale(Xm[,24]), BNDVI2 = scale(Xm[,25]))
XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI1 = scale(Xm[,9]), GDVI2 = scale(Xm[,10]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI1 = scale(Xm[,12]), GIPVI1 = scale(Xm[,13]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI1 = scale(Xm[,15]), GNDVI2 = scale(Xm[,16]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI1 = scale(Xm[,18]), GRVI2 = scale(Xm[,19]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI1 = scale(Xm[,21]), GSAVI2 = scale(Xm[,22]))

n.covariates.poly= 6 # Intercept (1) + Year (1) + Season (2) + polinomio del indice de vegetacion (2)
n.covariates= 5 # Intercept (1) + Year (1) + Season (2) +termino lineal del indice de vegetacion (1) --> No intorudcimos el termino cuadratico porque no fue significativo

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI1) + scale(BNDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI1) + scale(GDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI1) + scale(GIPVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI1) + scale(GNDVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI1) + scale(GRVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI1) + scale(GSAVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates.poly)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de predatory arthropods** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de predatory arthropods
# BNDVI
model.INLA.BNDVI.Detri_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Detri_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Detri_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Detri_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Detri_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Detri_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+)

```{r}
model.INLA.BNDVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     



**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      


**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

  

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    


**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], BNDVI = scale(Xm[,23]))
XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI = scale(Xm[,8]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI = scale(Xm[,11]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI = scale(Xm[,14]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI = scale(Xm[,17]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI = scale(Xm[,20]))

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de detritiveres** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI
model.INLA.BNDVI.Detri_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Detri_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Detri_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Detri_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Detri_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Detri_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Detritiveres),
                   control.predictor = list(A = inla.stack.A(All.stacks_Detritiveres), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI** Término lineal (+)

```{r}
model.INLA.BNDVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Detritiveres,
                              tag = "Covariates")$data

Predichos <- model.INLA.BNDVI.Detri_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$BNDVI == unique(MyData$BNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (BNDVI= unique(MyData$BNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.BNDVI <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.BNDVI <- p.BNDVI +  geom_jitter (aes (x= BNDVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Detritivore arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.BNDVI.log <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.BNDVI.log <- p.BNDVI.log +  geom_jitter (aes (x= BNDVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Log detritivore arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Detritiveres,
                              tag = "Covariates")$data

Predichos <- model.INLA.GDVI.Detri_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GDVI == unique(MyData$GDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GDVI= unique(MyData$GDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GDVI <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GDVI <- p.GDVI +  geom_jitter (aes (x=GDVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GDVI.log <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GDVI.log <- p.GDVI.log +  geom_jitter (aes (x=GDVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```

**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Detritiveres,
                              tag = "Covariates")$data

Predichos <- model.INLA.GIPVI.Detri_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GIPVI == unique(MyData$GIPVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GIPVI= unique(MyData$GIPVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GIPVI <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GIPVI <- p.GIPVI +  geom_jitter (aes (x=GIPVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GIPVI.log <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GIPVI.log <- p.GIPVI.log +  geom_jitter (aes (x=GIPVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```     

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Detritiveres,
                              tag = "Covariates")$data

Predichos <- model.INLA.GNDVI.Detri_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GNDVI == unique(MyData$GNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GNDVI= unique(MyData$GNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GNDVI <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GNDVI <- p.GNDVI +  geom_jitter (aes (x=GNDVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GNDVI.log <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GNDVI.log <- p.GNDVI.log +  geom_jitter (aes (x=GNDVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```   

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Detritiveres,
                              tag = "Covariates")$data

Predichos <- model.INLA.GRVI.Detri_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GRVI == unique(MyData$GRVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GRVI= unique(MyData$GRVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GRVI <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GRVI <- p.GRVI +  geom_jitter (aes (x=GRVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("Detritivore arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GRVI.log <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GRVI.log <- p.GRVI.log +  geom_jitter (aes (x=GRVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("Log detritivore arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  

**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Detri_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Detritiveres,
                              tag = "Covariates")$data

Predichos <- model.INLA.GSAVI.Detri_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GSAVI == unique(MyData$GSAVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GSAVI= unique(MyData$GSAVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GSAVI <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GSAVI <- p.GSAVI +  geom_jitter (aes (x=GSAVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GSAVI.log <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GSAVI.log <- p.GSAVI.log +  geom_jitter (aes (x=GSAVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


##### **Paso 9**. Representar los resultados conjuntamente:

En los nuevos gráficos el 95% Bayesian Confidence Interval se hace más estrecho:    

```{r, fig.width= 15, fig.height= 24}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E"),
          nrow= 4, ncol= 2)
```
 
 Horizontal:

```{r, fig.width= 25, fig.height= 13}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E"),
          nrow= 2, ncol= 3)
```

En escala natural:
```{r, fig.width= 25, fig.height= 13, warning= FALSE}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI, p.GIPVI,
          p.GNDVI, p.GRVI, p.GSAVI,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 2, ncol= 3)
```


#### C. **Biomasa de phytophagous arthropods**

##### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de phytophagous** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
Null.INLA.Phyto <- inla(f2.null,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# BNDVI
model.INLA.BNDVI.Phyto <- inla(f2.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Phyto <- inla(f2.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Phyto <- inla(f2.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Phyto <- inla(f2.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Phyto <- inla(f2.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Phyto <- inla(f2.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Phyto <- inla(f2.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```    


##### **Paso 8**. Explorar los resultados

**BNDVI** Termino lineal (+)

```{r}
model.INLA.BNDVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**ENDVI** Termino lineal (+)

```{r}
model.INLA.ENDVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GDVI** Termino lineal (+)

```{r}
model.INLA.GDVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GIPVI** Termino lineal (+)

```{r}
model.INLA.GIPVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GNDVI** Termino lineal (+)

```{r}
model.INLA.GNDVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GRVI** Termino lineal (+)

```{r}
model.INLA.GRVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GSAVI** Termino lineal (+)

```{r}
model.INLA.GSAVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
``` 

 
##### **Paso 10**. Validacion del modelo ¿Existe spatial confounding?

**A.** Obtenemos los interceptos aleatorios espaciales para cada observación en cada uno de los modelos

```{r}
w.proj <- inla.mesh.projector(mesh, loc =  Loc)

# u_i para cada modelo
w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Phyto$summary.random$w$mean)
w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Phyto$summary.random$w$mean)
w.pm_GDVI   <- inla.mesh.project(w.proj, model.INLA.GDVI.Phyto$summary.random$w$mean)
w.pm_GIPVI   <- inla.mesh.project(w.proj, model.INLA.GIPVI.Phyto$summary.random$w$mean)
w.pm_GNDVI   <- inla.mesh.project(w.proj, model.INLA.GNDVI.Phyto$summary.random$w$mean)
w.pm_GRVI   <- inla.mesh.project(w.proj, model.INLA.GRVI.Phyto$summary.random$w$mean)
w.pm_GSAVI   <- inla.mesh.project(w.proj, model.INLA.GSAVI.Phyto$summary.random$w$mean)
```

**B.** Ajustamos un modelo enfrentando los valores del intercepto aleatorio espacial frente a la covariable con la que sospechamos que puede existir Spatial Confounding (en este caso, los índices de vegetación)

En el caso del **BNDVI** observamos que NO existe 'Spatial Confounding', es decir, el término lineal del 'bndvi' NO está relacionado con la componente espacial del modelo. Por lo tanto, los resultados presentados mas arriba son contundentes.

```{r}
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

Ajustamos de nuevo el modelo sin el termino cuadratico porque no era significativo. Y comprobamos que NO hay spatial confounding:
```{r}
# BNDVI Modelo Espacial f(w, model= spde)
f2.BNDVIb <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI1) + f(w, model = spde)

# BNDVI
model.INLA.BNDVI.Phyto <- inla(f2.BNDVIb,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
model.INLA.BNDVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]

w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Phyto$summary.random$w$mean)
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.BNDVI.Phyto$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$BNDVI == unique(MyData$BNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (BNDVI= unique(MyData$BNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.BNDVI <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.BNDVI <- p.BNDVI +  geom_jitter (aes (x= BNDVI, y = 10^(LPhytophagous)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Phytophagous arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.BNDVI.log <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.BNDVI.log <- p.BNDVI.log +  geom_jitter (aes (x= BNDVI, y = LPhytophagous), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Log phytophagous arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


En el caso del **ENDVI** NO existe 'Spatial Confounding', ni en el término lineal ni en el término cuadrático
```{r echo= FALSE}
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI) + scale(ENDVI2),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```        

Ajustamos de nuevo el modelo sin el termino cuadratico porque no era significativo. Y comprobamos que NO hay spatial confounding:
```{r}
# ENDVI Modelo Espacial f(w, model= spde)
f2.ENDVIb <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(ENDVI1) + f(w, model = spde)

# ENDVI
model.INLA.ENDVI.Phyto <- inla(f2.ENDVIb,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
model.INLA.ENDVI.Phyto$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]

w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Phyto$summary.random$w$mean)
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.ENDVI.Phyto$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$ENDVI == unique(MyData$ENDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (ENDVI= unique(MyData$ENDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.ENDVI <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.ENDVI <- p.ENDVI +  geom_jitter (aes (x= ENDVI, y = 10^(LPhytophagous)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.ENDVI.log <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.ENDVI.log <- p.ENDVI.log +  geom_jitter (aes (x= ENDVI, y = LPhytophagous), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


En el caso del **GDVI** existe 'Spatial Confounding', tanto en el término lineal como en el término cuadrático. Por lo tanto, los resultados expuestos anteriormente no son contundentes.

```{r echo= FALSE}
SCgdvi <- inla (w.pm_GDVI ~ scale(GDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgdvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GIPVI** existe 'Spatial Confounding' en el término lineal

```{r echo= FALSE}
SCgipvi <- inla (w.pm_GIPVI ~ scale(GIPVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgipvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GNDVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgndvi <- inla (w.pm_GNDVI ~ scale(GNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GRVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgrvi <- inla (w.pm_GRVI ~ scale(GRVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgrvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GSAVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgsavi <- inla (w.pm_GSAVI ~ scale(GSAVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgsavi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

A continuación, ajustamos de nuevo los modelos estableciendo restricciones en la componente espacial (para que sea ortogonal a las covariables).     

##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI1 = scale(Xm[,9]), GDVI2 = scale(Xm[,10]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI1 = scale(Xm[,12]), GIPVI1 = scale(Xm[,13]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI1 = scale(Xm[,15]), GNDVI2 = scale(Xm[,16]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI1 = scale(Xm[,18]), GRVI2 = scale(Xm[,19]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI1 = scale(Xm[,21]), GSAVI2 = scale(Xm[,22]))

n.covariates.poly= 6 # Intercept (1) + Year (1) + Season (2) + polinomio del indice de vegetacion (2)
n.covariates= 5 # Intercept (1) + Year (1) + Season (2) +termino lineal del indice de vegetacion (1) --> No intorudcimos el termino cuadratico porque no fue significativo

Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI1) + scale(GDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI1) + scale(GIPVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI1) + scale(GNDVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI1) + scale(GRVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI1) + scale(GSAVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates.poly)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de predatory arthropods** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de predatory arthropods
# GDVI
model.INLA.GDVI.Phyto_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Phyto_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Phyto_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Phyto_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Phyto_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      


**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

  

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    


**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI = scale(Xm[,8]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI = scale(Xm[,11]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI = scale(Xm[,14]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI = scale(Xm[,17]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI = scale(Xm[,20]))

Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de phytophagous** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# GDVI
model.INLA.GDVI.Phyto_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Phyto_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Phyto_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Phyto_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Phyto_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Phytophagous),
                   control.predictor = list(A = inla.stack.A(All.stacks_Phytophagous), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados


**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.GDVI.Phyto_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GDVI == unique(MyData$GDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GDVI= unique(MyData$GDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GDVI <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GDVI <- p.GDVI +  geom_jitter (aes (x=GDVI, y = 10^(LPhytophagous)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GDVI.log <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GDVI.log <- p.GDVI.log +  geom_jitter (aes (x=GDVI, y = LPhytophagous), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```

**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.GIPVI.Phyto_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GIPVI == unique(MyData$GIPVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GIPVI= unique(MyData$GIPVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GIPVI <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GIPVI <- p.GIPVI +  geom_jitter (aes (x=GIPVI, y = 10^(LPhytophagous)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GIPVI.log <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GIPVI.log <- p.GIPVI.log +  geom_jitter (aes (x=GIPVI, y = LPhytophagous), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```     

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.GNDVI.Phyto_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GNDVI == unique(MyData$GNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GNDVI= unique(MyData$GNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GNDVI <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GNDVI <- p.GNDVI +  geom_jitter (aes (x=GNDVI, y = 10^(LPhytophagous)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Phytophagous arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GNDVI.log <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GNDVI.log <- p.GNDVI.log +  geom_jitter (aes (x=GNDVI, y = LPhytophagous), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Log phytophagous arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```   

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.GRVI.Phyto_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GRVI == unique(MyData$GRVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GRVI= unique(MyData$GRVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GRVI <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GRVI <- p.GRVI +  geom_jitter (aes (x=GRVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GRVI.log <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GRVI.log <- p.GRVI.log +  geom_jitter (aes (x=GRVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  

**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Phyto_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Phytophagous,
                              tag = "Covariates")$data

Predichos <- model.INLA.GSAVI.Phyto_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GSAVI == unique(MyData$GSAVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GSAVI= unique(MyData$GSAVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GSAVI <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GSAVI <- p.GSAVI +  geom_jitter (aes (x=GSAVI, y = 10^(LPhytophagous)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GSAVI.log <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GSAVI.log <- p.GSAVI.log +  geom_jitter (aes (x=GSAVI, y = LPhytophagous), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


##### **Paso 9**. Representar los resultados conjuntamente:

En los nuevos gráficos el 95% Bayesian Confidence Interval se hace más estrecho:    

```{r, fig.width= 15, fig.height= 24}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E"),
          nrow= 3, ncol= 2)
```
 
 Horizontal:

```{r, fig.width= 25, fig.height= 14.5}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E"),
          nrow= 2, ncol= 3)
```

En escala natural:
```{r, fig.width= 25, fig.height= 13, warning= FALSE}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI, p.ENDVI, p.GIPVI,
          p.GNDVI, p.GRVI, p.GSAVI,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 2, ncol= 3)
```


#### D. **Biomasa de diverse arthropods**

##### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de phytophagous** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
Null.INLA.Diverse <- inla(f2.null,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# BNDVI
model.INLA.BNDVI.Diverse <- inla(f2.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Diverse <- inla(f2.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Diverse <- inla(f2.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Diverse <- inla(f2.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Diverse <- inla(f2.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Diverse <- inla(f2.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Diverse <- inla(f2.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

```    


##### **Paso 8**. Explorar los resultados

**BNDVI** Termino lineal (+)

```{r}
model.INLA.BNDVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**ENDVI** Termino lineal (+)

```{r}
model.INLA.ENDVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GDVI** Termino lineal (+)

```{r}
model.INLA.GDVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GIPVI** Termino lineal (+)

```{r}
model.INLA.GIPVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GNDVI** Termino lineal (+)

```{r}
model.INLA.GNDVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

**GRVI** Termino lineal (+)

```{r}
model.INLA.GRVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

**GSAVI** Termino lineal (+)

```{r}
model.INLA.GSAVI.Diverse$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
``` 

 
##### **Paso 10**. Validacion del modelo ¿Existe spatial confounding?

**A.** Obtenemos los interceptos aleatorios espaciales para cada observación en cada uno de los modelos

```{r}
w.proj <- inla.mesh.projector(mesh, loc =  Loc)

# u_i para cada modelo
w.pm_BNDVI   <- inla.mesh.project(w.proj, model.INLA.BNDVI.Diverse$summary.random$w$mean)
w.pm_ENDVI   <- inla.mesh.project(w.proj, model.INLA.ENDVI.Diverse$summary.random$w$mean)
w.pm_GDVI   <- inla.mesh.project(w.proj, model.INLA.GDVI.Diverse$summary.random$w$mean)
w.pm_GIPVI   <- inla.mesh.project(w.proj, model.INLA.GIPVI.Diverse$summary.random$w$mean)
w.pm_GNDVI   <- inla.mesh.project(w.proj, model.INLA.GNDVI.Diverse$summary.random$w$mean)
w.pm_GRVI   <- inla.mesh.project(w.proj, model.INLA.GRVI.Diverse$summary.random$w$mean)
w.pm_GSAVI   <- inla.mesh.project(w.proj, model.INLA.GSAVI.Diverse$summary.random$w$mean)
```

**B.** Ajustamos un modelo enfrentando los valores del intercepto aleatorio espacial frente a la covariable con la que sospechamos que puede existir Spatial Confounding (en este caso, los índices de vegetación)

En el caso del **BNDVI** observamos que existe 'Spatial Confounding', es decir, el término lineal del 'bndvi' está relacionado con la componente espacial del modelo. Por lo tanto, los resultados presentados mas arriba NO son contundentes.

```{r}
SCbndvi <- inla (w.pm_BNDVI ~ scale(BNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCbndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **ENDVI**  existe 'Spatial Confounding', ni en el término lineal ni en el término cuadrático
```{r echo= FALSE}
SCendvi <- inla (w.pm_ENDVI ~ scale(ENDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCendvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```        

En el caso del **GDVI** existe 'Spatial Confounding', tanto en el término lineal como en el término cuadrático. Por lo tanto, los resultados expuestos anteriormente no son contundentes.

```{r echo= FALSE}
SCgdvi <- inla (w.pm_GDVI ~ scale(GDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgdvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GIPVI** existe 'Spatial Confounding' en el término lineal

```{r echo= FALSE}
SCgipvi <- inla (w.pm_GIPVI ~ scale(GIPVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgipvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GNDVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgndvi <- inla (w.pm_GNDVI ~ scale(GNDVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgndvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GRVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgrvi <- inla (w.pm_GRVI ~ scale(GRVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgrvi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

En el caso del **GSAVI** existe 'Spatial Confounding' en los términos lineal y cuadrático

```{r echo= FALSE}
SCgsavi <- inla (w.pm_GSAVI ~ scale(GSAVI),
               family= "gaussian",
                data = X,
                   control.compute = list(dic = TRUE, waic = TRUE)
                    )
SCgsavi$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```

A continuación, ajustamos de nuevo los modelos estableciendo restricciones en la componente espacial (para que sea ortogonal a las covariables).     

##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], BNDVI1 = scale(Xm[,24]), BNDVI2 = scale(Xm[,25]))
XENDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI1 = scale(Xm[,6]), GDVI2 = scale(Xm[,7]))
XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI1 = scale(Xm[,9]), GDVI2 = scale(Xm[,10]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI1 = scale(Xm[,12]), GIPVI1 = scale(Xm[,13]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI1 = scale(Xm[,15]), GNDVI2 = scale(Xm[,16]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI1 = scale(Xm[,18]), GRVI2 = scale(Xm[,19]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI1 = scale(Xm[,21]), GSAVI2 = scale(Xm[,22]))

n.covariates.poly= 6 # Intercept (1) + Year (1) + Season (2) + polinomio del indice de vegetacion (2)
n.covariates= 5 # Intercept (1) + Year (1) + Season (2) +termino lineal del indice de vegetacion (1) --> No intorudcimos el termino cuadratico porque no fue significativo

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.ENDVI = qr.Q(qr(XENDVI))
Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI1) + scale(BNDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.ENDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(ENDVI1) + scale(ENDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.ENDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI1) + scale(GDVI2) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI1) + scale(GIPVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI1) + scale(GNDVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI1) + scale(GRVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates.poly)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI1) + scale(GSAVI2) + 
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates.poly)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de predatory arthropods** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de predatory arthropods
# BNDVI
model.INLA.BNDVI.Diverse_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Diverse_SC <- inla(f3.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Diverse_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Diverse_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Diverse_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Diverse_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Diverse_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.BNDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  

**ENDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.ENDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  

**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      


**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

  

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    


**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


##### **Paso 5**. Hacer un stack 

Para establecer restricciones en la componente en la espacial necesitamos lo siguiente:
```{r}
# En algunos ejemplos las restricciones las establecen a todos los predictores, nosotros lo hacemos unicamente a los que es sensato pensar que haya spatial confounding (y que ha sido testada anteriormente), los indices de vegetacion

XBNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], BNDVI = scale(Xm[,23]))
XENDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], ENDVI = scale(Xm[,5]))
XGDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GDVI = scale(Xm[,8]))
XGIPVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GIPVI = scale(Xm[,11]))
XGNDVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GNDVI = scale(Xm[,14]))
XGRVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GRVI = scale(Xm[,17]))
XGSAVI <- data.frame(Intercept= Xm[,1], Year2018= Xm[,2], seasonspring= Xm[,3], seasonsummer= Xm[,4], GSAVI = scale(Xm[,20]))

Qfact.BNDVI = qr.Q(qr(XBNDVI))
Qfact.ENDVI = qr.Q(qr(XENDVI))
Qfact.GDVI = qr.Q(qr(XGDVI))
Qfact.GIPVI = qr.Q(qr(XGIPVI))
Qfact.GNDVI = qr.Q(qr(XGNDVI))
Qfact.GRVI = qr.Q(qr(XGRVI))
Qfact.GSAVI = qr.Q(qr(XGSAVI))

```


### **Paso 6**. Especificar la fórmula del modelo en términos de la variables respuesta, covariables y el término de autocorrelación espacial.

Describimos las ecuaciones de los modelos. No lo describimos para el ENDVI porque no presentó spatial confounding. En todos los casos, testamos inicialmente el efecto del termino lineal y cuadrático. No obstante, si el término cuadrático no tuvo un efecto, lo borramos finalmente de la ecuación del modelo.

```{r}
f3.BNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(BNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.BNDVI)%*%A2), e= rep(0,n.covariates)))

f3.ENDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(ENDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.ENDVI)%*%A2), e= rep(0,n.covariates)))

f3.GDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GDVI)%*%A2), e= rep(0,n.covariates)))

f3.GIPVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GIPVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GIPVI)%*%A2), e= rep(0,n.covariates)))

f3.GNDVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GNDVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GNDVI)%*%A2), e= rep(0,n.covariates)))

f3.GRVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GRVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GRVI)%*%A2), e= rep(0,n.covariates)))

f3.GSAVI <- y ~ -1 + Intercept + Year2018 + seasonspring + seasonsummer + scale(GSAVI) +
  f(w, model = spde, extraconstr = list(A = as.matrix(t(Qfact.GSAVI)%*%A2), e= rep(0,n.covariates)))

```


### **Paso 7**. Correr el modelo en INLA

Ajustamos los modelos para la **biomasa de detritiveres** y todos los índices de vegetación:

```{r}
#*2* Analizando el efecto de los indices de vegetacion en la biomasa de epigeos
# BNDVI
model.INLA.BNDVI.Diverse_SC <- inla(f3.BNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# ENDVI
model.INLA.ENDVI.Diverse_SC <- inla(f3.ENDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GDVI
model.INLA.GDVI.Diverse_SC <- inla(f3.GDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GIPVI
model.INLA.GIPVI.Diverse_SC <- inla(f3.GIPVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GNDVI
model.INLA.GNDVI.Diverse_SC <- inla(f3.GNDVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GRVI
model.INLA.GRVI.Diverse_SC <- inla(f3.GRVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial

# GSAVI
model.INLA.GSAVI.Diverse_SC <- inla(f3.GSAVI,
                   family = "gaussian", 
                   data = inla.stack.data(All.stacks_Diverse),
                   control.predictor = list(A = inla.stack.A(All.stacks_Diverse), compute= TRUE),
                   control.compute = list(waic= TRUE, dic= TRUE)) # Modelo Espacial
```


##### **Paso 8**. Explorar los resultados

**BNDVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.BNDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.BNDVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$BNDVI == unique(MyData$BNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (BNDVI= unique(MyData$BNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.BNDVI <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.BNDVI <- p.BNDVI +  geom_jitter (aes (x= BNDVI, y = 10^(LDiverse)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Diverse arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.BNDVI.log <- ggplot(data=MyData1, aes(x=BNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.BNDVI.log <- p.BNDVI.log +  geom_jitter (aes (x= BNDVI, y = LDiverse), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("BNDVI") + 
  ylab("Log diverse arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


**ENDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.ENDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```   

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.ENDVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$ENDVI == unique(MyData$ENDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (ENDVI= unique(MyData$ENDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.ENDVI <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.ENDVI <- p.ENDVI +  geom_jitter (aes (x= ENDVI, y = 10^(LDiverse)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.ENDVI.log <- ggplot(data=MyData1, aes(x=ENDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.ENDVI.log <- p.ENDVI.log +  geom_jitter (aes (x= ENDVI, y = LDiverse), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("ENDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```



**GDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```      

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.GDVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GDVI == unique(MyData$GDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GDVI= unique(MyData$GDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GDVI <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GDVI <- p.GDVI +  geom_jitter (aes (x=GDVI, y = 10^(LDiverse)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GDVI.log <- ggplot(data=MyData1, aes(x=GDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GDVI.log <- p.GDVI.log +  geom_jitter (aes (x=GDVI, y = LDiverse), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GDVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```

**GIPVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GIPVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.GIPVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GIPVI == unique(MyData$GIPVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GIPVI= unique(MyData$GIPVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GIPVI <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GIPVI <- p.GIPVI +  geom_jitter (aes (x=GIPVI, y = 10^(LDiverse)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GIPVI.log <- ggplot(data=MyData1, aes(x=GIPVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GIPVI.log <- p.GIPVI.log +  geom_jitter (aes (x=GIPVI, y = LDiverse), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GIPVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))


```     

**GNDVI** Termino lineal (+)
```{r echo= FALSE}
model.INLA.GNDVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```     

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.GNDVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GNDVI == unique(MyData$GNDVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GNDVI= unique(MyData$GNDVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GNDVI <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GNDVI <- p.GNDVI +  geom_jitter (aes (x=GNDVI, y = 10^(LDiverse)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Diverse arthropodos (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GNDVI.log <- ggplot(data=MyData1, aes(x=GNDVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GNDVI.log <- p.GNDVI.log +  geom_jitter (aes (x=GNDVI, y = LDiverse), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GNDVI") + 
  ylab("Log diverse arthropods (mg)") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```   

**GRVI**  Termino lineal (+)
```{r echo= FALSE}
model.INLA.GRVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```    

```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.GRVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GRVI == unique(MyData$GRVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GRVI= unique(MyData$GRVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GRVI <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GRVI <- p.GRVI +  geom_jitter (aes (x=GRVI, y = 10^(LDetritiveres)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GRVI.log <- ggplot(data=MyData1, aes(x=GRVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GRVI.log <- p.GRVI.log +  geom_jitter (aes (x=GRVI, y = LDetritiveres), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GRVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  

**GSAVI** Termino lineal(+)
```{r echo= FALSE}
model.INLA.GSAVI.Diverse_SC$summary.fixed[, c("mean", "sd", "0.025quant", "0.975quant")]
```  


```{r echo= FALSE}
index.Cov <- inla.stack.index(All.stacks_Diverse,
                              tag = "Covariates")$data

Predichos <- model.INLA.GSAVI.Diverse_SC$summary.fitted.values[index.Cov, c(1,3,5)]

# Mean values
Predicted.mean <- vector(length= 1000)
Predicted.BCILow <- vector(length= 1000) 
Predicted.BCIHigh <- vector(length= 1000)

for(x in 1:1000){
  items <- which(MyData$GSAVI == unique(MyData$GSAVI)[x])
  Predicted.mean [x] <- mean(Predichos[items, 1])
  Predicted.BCILow [x] <- mean(Predichos[items, 2])
  Predicted.BCIHigh [x] <- mean(Predichos[items, 3])
}

# It is the second one we need as these are for the
# artificial covariate values.
# Add them to the MyData object.
MyData1 <- data.frame (GSAVI= unique(MyData$GSAVI), Predicted.mean, Predicted.BCILow, Predicted.BCIHigh) 

MyData1 <- rename(MyData1, 
                  c("Predicted.mean" = "Predicted.meanlog", 
                    "Predicted.BCILow" = "Predicted.BCILowlog",
                    "Predicted.BCIHigh" = "Predicted.BCIHighlog"))
MyData1$Predicted.mean <- 10^(MyData1$Predicted.meanlog) - 1
MyData1$Predicted.BCIHigh <- 10^(MyData1$Predicted.BCIHighlog) -1
MyData1$Predicted.BCILow <- 10^(MyData1$Predicted.BCILowlog) -1

p.GSAVI <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILow, ymax = Predicted.BCIHigh,  y= Predicted.mean)) + 
  geom_line(size= 1) + 
  geom_ribbon(alpha=0.3)

p.GSAVI <- p.GSAVI +  geom_jitter (aes (x=GSAVI, y = 10^(LDiverse)-1), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


```{r echo= FALSE}
p.GSAVI.log <- ggplot(data=MyData1, aes(x=GSAVI, ymin = Predicted.BCILowlog, ymax = Predicted.BCIHighlog,  y= Predicted.meanlog)) + 
  geom_line(size= 1.5) + 
  geom_ribbon(alpha=0.3)

p.GSAVI.log <- p.GSAVI.log +  geom_jitter (aes (x=GSAVI, y = LDiverse), data= Data, alpha= 0.6, inherit.aes = FALSE, size= 4, show.legend = FALSE) +
  xlab("GSAVI") + 
  ylab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                   panel.background = element_blank(), axis.line = element_line(colour = "black", size= 1.5), 
                                                axis.title.x = element_text(size = 30, margin = margin(t = 5, r = 0, b = 0, l = 0)),
                                                axis.title.y = element_text(size = 30, margin = margin(t = 0, r = 10, b = 0, l = 0)), 
                                                axis.text = element_text(size= 25), plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))

```  


##### **Paso 9**. Representar los resultados conjuntamente:

En los nuevos gráficos el 95% Bayesian Confidence Interval se hace más estrecho:    

```{r, fig.width= 15, fig.height= 24}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E"),
          nrow= 3, ncol= 2)
```
 
 Horizontal:

```{r, fig.width= 25, fig.height= 15}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI.log, p.ENDVI.log, p.GIPVI.log,
          p.GNDVI.log, p.GRVI.log, p.GSAVI.log,
          lables= c("A", "B", "C", "D", "E"),
          nrow= 2, ncol= 3)
```

En escala natural:
```{r, fig.width= 25, fig.height= 13, warning= FALSE}
# create an apporpriate viewport.  Modify the dimensions and coordinates as needed
plot_grid(p.BNDVI, p.ENDVI, p.GIPVI,
          p.GNDVI, p.GRVI, p.GSAVI,
          lables= c("A", "B", "C", "D", "E", "F", "G"),
          nrow= 2, ncol= 3)
```